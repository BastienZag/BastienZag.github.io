(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function startEmailInputDirective() {
	'use strict';
	var componentsModule = angular.module('start.forms.components.emailInput', []);
	componentsModule.directive('startEmailInput', emailInput);

	emailInput.$inject = [];

	function emailInput() {
		var directive = {
			restrict: 'EA',
			template: require('./email-input-template.html'),
			scope: {
				options: '='
			}
		};

		return directive;
	}
})();

},{"./email-input-template.html":2}],2:[function(require,module,exports){
module.exports = "\n\t<input\n\tid=\"{{ options.fieldId }}\"\n\tname=\"{{ options.fieldId }}\"\n\ttype=\"email\"\n\tclass=\"form-control\"\n\tng-model=\"options.fieldModel\"\n\tplaceholder=\"{{ options.fieldPlaceholder }}\"\n\tng-disabled=\"options.isDisabled\"\n\tng-required=\"options.fieldRequired\">\n";

},{}],3:[function(require,module,exports){
(function emailInputInit() {
	'use strict';

	// declare the component angular module, you can inject dependencies here
	angular.module('start.forms.components.emailInput', []);

	// Require your components here
	require('./email-input-directive.js');

}());

},{"./email-input-directive.js":1}],4:[function(require,module,exports){
// Generated by grunt: browserify-imports
(function moduleInit_startFormsComponents() {

	// Add require for other modules here

	// Grunt browserify-imports require all components with an index.js here
	// StartRequire
	require('./email-input');
	require('./text-input');
	var angularModuleDependencies = ["start.forms.components.emailInput","start.forms.components.textInput"];
	// EndRequire

	// Add your angular module dependencies here
	// angularModuleDependencies.push('other.module');

	try {
		console.log('loading module start.forms.components');
		angular.module('start.forms.components', angularModuleDependencies);
	} catch (e) {
		console.log('start.forms.components is already defined.');}
	}
)();

},{"./email-input":3,"./text-input":5}],5:[function(require,module,exports){
(function textInputInit() {
	'use strict';

	// declare the component angular module, you can inject dependencies here
	angular.module('start.forms.components.textInput', []);

	// Require your components here
	require('./text-input-directive.js');

}());

},{"./text-input-directive.js":6}],6:[function(require,module,exports){
(function startTextInputDirective() {
	'use strict';
	var componentsModule = angular.module('start.forms.components.textInput', []);
	componentsModule.directive('startTextInput', textInput);

	textInput.$inject = [];

	function textInput() {
		var directive = {
			restrict: 'EA',
			template: require('./text-input-template.html'),
			scope: {
				options: '='
			}
		};

		return directive;
	}
})();

},{"./text-input-template.html":7}],7:[function(require,module,exports){
module.exports = "\n\t<input\n\tid=\"{{ options.fieldId }}\"\n\tname=\"{{ options.fieldId }}\"\n\ttype=\"text\"\n\tclass=\"form-control\"\n\tplaceholder=\"{{ options.fieldPlaceholder }}\"\n\tng-model=\"options.fieldModel\"\n\tng-disabled=\"options.isDisabled\"\n\tng-required=\"options.fieldRequired\">\n";

},{}],8:[function(require,module,exports){
// Generated by grunt: browserify-imports
(function moduleInit_startFormsFieldsets() {

	// Add require for other modules here
	require('angular-messages');
	require('../start.forms.components');

	// Grunt browserify-imports require all components with an index.js here
	// StartRequire
	require('./input-row');
	var angularModuleDependencies = ["start.forms.fieldsets.inputRow"];
	// EndRequire

	// Add your angular module dependencies here
	angularModuleDependencies.push('ngMessages');
	angularModuleDependencies.push('start.forms.components');

	try {
		console.log('loading module start.forms.fieldsets');
		angular.module('start.forms.fieldsets', angularModuleDependencies);
	} catch (e) {
		console.log('start.forms.fieldsets is already defined.');}
	}
)();

},{"../start.forms.components":4,"./input-row":9,"angular-messages":17}],9:[function(require,module,exports){
(function inputRowTextInit() {
	'use strict';

	// declare the component angular module, you can inject dependencies here
	angular.module('start.forms.fieldsets.inputRow', []);

	// Require your components here
	require('./input-row-directive.js');

}());

},{"./input-row-directive.js":10}],10:[function(require,module,exports){
(function startInputRowTextDirective() {
	'use strict';
	var componentsModule = angular.module('start.forms.fieldsets.inputRow', [ 'start.forms.components.textInput']);
	componentsModule.directive('startInputRow', startInputRow);

	startInputRow.$inject = [];

	function startInputRow() {
		var directive = {
			transclude: true,
			restrict: 'EA',
			template: require('./input-row-template.html'),
			scope: {
				label: '@',
				fieldModel: '=',
				fieldType: '@',
				fieldId: '@',
				fieldRequired: '=',
				fieldPlaceholder: '@?'
			},
			bindToController: true,
			controller: ['$scope', '$attrs', function(scope, $attrs) {}],
			controllerAs: 'fieldCtrl'
		};

		return directive;
	}
})();

},{"./input-row-template.html":11}],11:[function(require,module,exports){
module.exports = "<!-- ng-form=\"fieldForm\" -->\n<div ng-form=\"fieldForm\" ng-class=\"{'has-button{' : button}\" class=\"input-row input-row-text {{ class }} clearfix\">\n\n\t<div ng-disabled=\"disabled\" class=\"input-row-label form-left\">\n\t\t<label class=\"form-label\" for=\"{{ fieldCtrl.fieldId }}\">{{ fieldCtrl.label }}</label>\n\t\t<ng-transclude></ng-transclude>\n\t</div>\n\n\t<div class=\"form-right\">\n\n\t\t<div ng-switch=\"fieldCtrl.fieldType\">\n\t\t\t<start-text-input ng-switch-when=\"text\" options=\"fieldCtrl\"></start-text-input>\n\t\t\t<start-email-input ng-switch-when=\"email\" options=\"fieldCtrl\"></start-email-input>\n\t\t</div>\n\n\t\t<div class=\"errors\" ng-messages=\"fieldForm[fieldCtrl.fieldId].$dirty && fieldForm[fieldCtrl.fieldId].$error\" role=\"alert\">\n\t\t\t<div ng-message=\"required\">You did not enter a value for this field</div>\n\t\t\t<div ng-message=\"email\">It's not a valid email</div>\n\t\t</div>\n\n\t</div>\n</div>\n";

},{}],12:[function(require,module,exports){
// Generated by grunt: browserify-imports
(function moduleInit_startForms() {

	// Add require for other modules here
	require('angular-messages');
	require('../start.forms.fieldsets');

	// require('../gui.ng.components');

	// Grunt browserify-imports require all components with an index.js here
	// StartRequire
	require('./register');
	var angularModuleDependencies = ["start.forms.register"];
	// EndRequire

	// Add your angular module dependencies here
	angularModuleDependencies.push('ngMessages');
	angularModuleDependencies.push('start.forms.fieldsets');
	// angularModuleDependencies.push('gui.ng.components');

	try {
		console.log('loading module start.forms');
		angular.module('start.forms', angularModuleDependencies);
	} catch (e) {
		console.log('start.forms is already defined.');}
	}
)();

},{"../start.forms.fieldsets":8,"./register":13,"angular-messages":17}],13:[function(require,module,exports){
(function registerInit() {
	'use strict';

	// declare the component angular module, you can inject dependencies here
	angular.module('start.forms.register', []);

	// Require your components here
	require('./register-directive.js');

}());

},{"./register-directive.js":14}],14:[function(require,module,exports){
(function startRegisterDirective() {
	'use strict';

	var componentsModule = angular.module('start.forms.register', []);
	componentsModule.directive('startRegister', register);

	register.$inject = [];

	function register() {
		var directive = {
			restrict: 'EA',
			template: require('./register-template.html'),
			scope: {},
			controller : ['$scope', '$attrs', function(scope, $attrs) {
				scope.formData = {};

				this.handleSubmit = function(valid, formData) {
					if (valid) {
						scope.$eval($attrs.onValidSubmit);
						console.log('data submitted:');
						console.log( formData );
						scope.dataSubmitted = JSON.stringify(formData);
					} else {
						console.log('form invalid');
					}
				};

			}],
			controllerAs: 'ctrl',
		};

		return directive;
	}
})();

},{"./register-template.html":15}],15:[function(require,module,exports){
module.exports = "<div class=\"start-register\">\n\n\t<h2 class=\"body-font\">Register form</h2>\n\t<form name=\"registerForm\" class=\"start-register-form\" ng-submit=\"ctrl.handleSubmit(registerForm.$valid, formData)\" novalidate>\n\n\t\t<p ng-if=\"registerForm.$submitted && registerForm.$error\">\n\t\t\tPlease fix the errors in your form:\n\t\t</p>\n\n\t\t<start-input-row\n\t\tlabel=\"First name\"\n\t\tfield-model=\"formData.firstName\"\n\t\tfield-type=\"text\"\n\t\tfield-id=\"registerForm-firstName\"\n\t\tfield-placeholder=\"enter your first name\"\n\t\tfield-required=\"true\">\n\t\t<!-- <gui-popover></gui-popover> -->\n\t\t</start-input-row>\n\n\t\t<start-input-row\n\t\tlabel=\"Last name\"\n\t\tfield-model=\"formData.lastName\"\n\t\tfield-type=\"text\"\n\t\tfield-id=\"registerForm-lastName\"\n\t\tfield-required=\"true\">\n\t\t</start-input-row>\n\n\t\t<start-input-row\n\t\tlabel=\"Email\"\n\t\tfield-model=\"formData.email\"\n\t\tfield-type=\"email\"\n\t\tfield-id=\"registerForm-email\"\n\t\tfield-required=\"true\">\n\t\t</start-input-row>\n\n\t\t<button class=\"btn btn-primary start-register-submit\">Submit</button>\n\n\t</form>\n\n\t<div>\n\t\t<h3>\n\t\t\tdata submited\n\t\t</h3>\n\t\t{{ dataSubmitted }}\n\t</div>\n</div>\n";

},{}],16:[function(require,module,exports){
/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* jshint ignore:start */
// this code is in the core, but not in angular-messages.js
var isArray = angular.isArray;
var forEach = angular.forEach;
var isString = angular.isString;
var jqLite = angular.element;
/* jshint ignore:end */

/**
 * @ngdoc module
 * @name ngMessages
 * @description
 *
 * The `ngMessages` module provides enhanced support for displaying messages within templates
 * (typically within forms or when rendering message objects that return key/value data).
 * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to
 * show and hide error messages specific to the state of an input field, the `ngMessages` and
 * `ngMessage` directives are designed to handle the complexity, inheritance and priority
 * sequencing based on the order of how the messages are defined in the template.
 *
 * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`
 * `ngMessage` and `ngMessageExp` directives.
 *
 * # Usage
 * The `ngMessages` directive listens on a key/value collection which is set on the ngMessages attribute.
 * Since the {@link ngModel ngModel} directive exposes an `$error` object, this error object can be
 * used with `ngMessages` to display control error messages in an easier way than with just regular angular
 * template directives.
 *
 * ```html
 * <form name="myForm">
 *   <label>
 *     Enter text:
 *     <input type="text" ng-model="field" name="myField" required minlength="5" />
 *   </label>
 *   <div ng-messages="myForm.myField.$error" role="alert">
 *     <div ng-message="required">You did not enter a field</div>
 *     <div ng-message="minlength, maxlength">
 *       Your email must be between 5 and 100 characters long
 *     </div>
 *   </div>
 * </form>
 * ```
 *
 * Now whatever key/value entries are present within the provided object (in this case `$error`) then
 * the ngMessages directive will render the inner first ngMessage directive (depending if the key values
 * match the attribute value present on each ngMessage directive). In other words, if your errors
 * object contains the following data:
 *
 * ```javascript
 * <!-- keep in mind that ngModel automatically sets these error flags -->
 * myField.$error = { minlength : true, required : true };
 * ```
 *
 * Then the `required` message will be displayed first. When required is false then the `minlength` message
 * will be displayed right after (since these messages are ordered this way in the template HTML code).
 * The prioritization of each message is determined by what order they're present in the DOM.
 * Therefore, instead of having custom JavaScript code determine the priority of what errors are
 * present before others, the presentation of the errors are handled within the template.
 *
 * By default, ngMessages will only display one error at a time. However, if you wish to display all
 * messages then the `ng-messages-multiple` attribute flag can be used on the element containing the
 * ngMessages directive to make this happen.
 *
 * ```html
 * <!-- attribute-style usage -->
 * <div ng-messages="myForm.myField.$error" ng-messages-multiple>...</div>
 *
 * <!-- element-style usage -->
 * <ng-messages for="myForm.myField.$error" multiple>...</ng-messages>
 * ```
 *
 * ## Reusing and Overriding Messages
 * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline
 * template. This allows for generic collection of messages to be reused across multiple parts of an
 * application.
 *
 * ```html
 * <script type="text/ng-template" id="error-messages">
 *   <div ng-message="required">This field is required</div>
 *   <div ng-message="minlength">This field is too short</div>
 * </script>
 *
 * <div ng-messages="myForm.myField.$error" role="alert">
 *   <div ng-messages-include="error-messages"></div>
 * </div>
 * ```
 *
 * However, including generic messages may not be useful enough to match all input fields, therefore,
 * `ngMessages` provides the ability to override messages defined in the remote template by redefining
 * them within the directive container.
 *
 * ```html
 * <!-- a generic template of error messages known as "my-custom-messages" -->
 * <script type="text/ng-template" id="my-custom-messages">
 *   <div ng-message="required">This field is required</div>
 *   <div ng-message="minlength">This field is too short</div>
 * </script>
 *
 * <form name="myForm">
 *   <label>
 *     Email address
 *     <input type="email"
 *            id="email"
 *            name="myEmail"
 *            ng-model="email"
 *            minlength="5"
 *            required />
 *   </label>
 *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will
 *        override the messages present in the ng-messages-include template -->
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <!-- this required message has overridden the template message -->
 *     <div ng-message="required">You did not enter your email address</div>
 *
 *     <!-- this is a brand new message and will appear last in the prioritization -->
 *     <div ng-message="email">Your email address is invalid</div>
 *
 *     <!-- and here are the generic error messages -->
 *     <div ng-messages-include="my-custom-messages"></div>
 *   </div>
 * </form>
 * ```
 *
 * In the example HTML code above the message that is set on required will override the corresponding
 * required message defined within the remote template. Therefore, with particular input fields (such
 * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied
 * while more generic messages can be used to handle other, more general input errors.
 *
 * ## Dynamic Messaging
 * ngMessages also supports using expressions to dynamically change key values. Using arrays and
 * repeaters to list messages is also supported. This means that the code below will be able to
 * fully adapt itself and display the appropriate message when any of the expression data changes:
 *
 * ```html
 * <form name="myForm">
 *   <label>
 *     Email address
 *     <input type="email"
 *            name="myEmail"
 *            ng-model="email"
 *            minlength="5"
 *            required />
 *   </label>
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <div ng-message="required">You did not enter your email address</div>
 *     <div ng-repeat="errorMessage in errorMessages">
 *       <!-- use ng-message-exp for a message whose key is given by an expression -->
 *       <div ng-message-exp="errorMessage.type">{{ errorMessage.text }}</div>
 *     </div>
 *   </div>
 * </form>
 * ```
 *
 * The `errorMessage.type` expression can be a string value or it can be an array so
 * that multiple errors can be associated with a single error message:
 *
 * ```html
 *   <label>
 *     Email address
 *     <input type="email"
 *            ng-model="data.email"
 *            name="myEmail"
 *            ng-minlength="5"
 *            ng-maxlength="100"
 *            required />
 *   </label>
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <div ng-message-exp="'required'">You did not enter your email address</div>
 *     <div ng-message-exp="['minlength', 'maxlength']">
 *       Your email must be between 5 and 100 characters long
 *     </div>
 *   </div>
 * ```
 *
 * Feel free to use other structural directives such as ng-if and ng-switch to further control
 * what messages are active and when. Be careful, if you place ng-message on the same element
 * as these structural directives, Angular may not be able to determine if a message is active
 * or not. Therefore it is best to place the ng-message on a child element of the structural
 * directive.
 *
 * ```html
 * <div ng-messages="myForm.myEmail.$error" role="alert">
 *   <div ng-if="showRequiredError">
 *     <div ng-message="required">Please enter something</div>
 *   </div>
 * </div>
 * ```
 *
 * ## Animations
 * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and
 * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from
 * the DOM by the `ngMessages` directive.
 *
 * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS
 * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no
 * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can
 * hook into the animations whenever these classes are added/removed.
 *
 * Let's say that our HTML code for our messages container looks like so:
 *
 * ```html
 * <div ng-messages="myMessages" class="my-messages" role="alert">
 *   <div ng-message="alert" class="some-message">...</div>
 *   <div ng-message="fail" class="some-message">...</div>
 * </div>
 * ```
 *
 * Then the CSS animation code for the message container looks like so:
 *
 * ```css
 * .my-messages {
 *   transition:1s linear all;
 * }
 * .my-messages.ng-active {
 *   // messages are visible
 * }
 * .my-messages.ng-inactive {
 *   // messages are hidden
 * }
 * ```
 *
 * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter
 * and leave animation is triggered for each particular element bound to the `ngMessage` directive.
 *
 * Therefore, the CSS code for the inner messages looks like so:
 *
 * ```css
 * .some-message {
 *   transition:1s linear all;
 * }
 *
 * .some-message.ng-enter {}
 * .some-message.ng-enter.ng-enter-active {}
 *
 * .some-message.ng-leave {}
 * .some-message.ng-leave.ng-leave-active {}
 * ```
 *
 * {@link ngAnimate Click here} to learn how to use JavaScript animations or to learn more about ngAnimate.
 */
angular.module('ngMessages', [])

   /**
    * @ngdoc directive
    * @module ngMessages
    * @name ngMessages
    * @restrict AE
    *
    * @description
    * `ngMessages` is a directive that is designed to show and hide messages based on the state
    * of a key/value object that it listens on. The directive itself complements error message
    * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).
    *
    * `ngMessages` manages the state of internal messages within its container element. The internal
    * messages use the `ngMessage` directive and will be inserted/removed from the page depending
    * on if they're present within the key/value object. By default, only one message will be displayed
    * at a time and this depends on the prioritization of the messages within the template. (This can
    * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)
    *
    * A remote template can also be used to promote message reusability and messages can also be
    * overridden.
    *
    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY ng-messages="expression" role="alert">
    *   <ANY ng-message="stringValue">...</ANY>
    *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
    *   <ANY ng-message-exp="expressionValue">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <ng-messages for="expression" role="alert">
    *   <ng-message when="stringValue">...</ng-message>
    *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
    *   <ng-message when-exp="expressionValue">...</ng-message>
    * </ng-messages>
    * ```
    *
    * @param {string} ngMessages an angular expression evaluating to a key/value object
    *                 (this is typically the $error object on an ngModel instance).
    * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true
    *
    * @example
    * <example name="ngMessages-directive" module="ngMessagesExample"
    *          deps="angular-messages.js"
    *          animations="true" fixBase="true">
    *   <file name="index.html">
    *     <form name="myForm">
    *       <label>
    *         Enter your name:
    *         <input type="text"
    *                name="myName"
    *                ng-model="name"
    *                ng-minlength="5"
    *                ng-maxlength="20"
    *                required />
    *       </label>
    *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>
    *
    *       <div ng-messages="myForm.myName.$error" style="color:maroon" role="alert">
    *         <div ng-message="required">You did not enter a field</div>
    *         <div ng-message="minlength">Your field is too short</div>
    *         <div ng-message="maxlength">Your field is too long</div>
    *       </div>
    *     </form>
    *   </file>
    *   <file name="script.js">
    *     angular.module('ngMessagesExample', ['ngMessages']);
    *   </file>
    * </example>
    */
   .directive('ngMessages', ['$animate', function($animate) {
     var ACTIVE_CLASS = 'ng-active';
     var INACTIVE_CLASS = 'ng-inactive';

     return {
       require: 'ngMessages',
       restrict: 'AE',
       controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
         var ctrl = this;
         var latestKey = 0;
         var nextAttachId = 0;

         this.getAttachId = function getAttachId() { return nextAttachId++; };

         var messages = this.messages = {};
         var renderLater, cachedCollection;

         this.render = function(collection) {
           collection = collection || {};

           renderLater = false;
           cachedCollection = collection;

           // this is true if the attribute is empty or if the attribute value is truthy
           var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||
                          isAttrTruthy($scope, $attrs.multiple);

           var unmatchedMessages = [];
           var matchedKeys = {};
           var messageItem = ctrl.head;
           var messageFound = false;
           var totalMessages = 0;

           // we use != instead of !== to allow for both undefined and null values
           while (messageItem != null) {
             totalMessages++;
             var messageCtrl = messageItem.message;

             var messageUsed = false;
             if (!messageFound) {
               forEach(collection, function(value, key) {
                 if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                   // this is to prevent the same error name from showing up twice
                   if (matchedKeys[key]) return;
                   matchedKeys[key] = true;

                   messageUsed = true;
                   messageCtrl.attach();
                 }
               });
             }

             if (messageUsed) {
               // unless we want to display multiple messages then we should
               // set a flag here to avoid displaying the next message in the list
               messageFound = !multiple;
             } else {
               unmatchedMessages.push(messageCtrl);
             }

             messageItem = messageItem.next;
           }

           forEach(unmatchedMessages, function(messageCtrl) {
             messageCtrl.detach();
           });

           unmatchedMessages.length !== totalMessages
              ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS)
              : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
         };

         $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);

         this.reRender = function() {
           if (!renderLater) {
             renderLater = true;
             $scope.$evalAsync(function() {
               if (renderLater) {
                 cachedCollection && ctrl.render(cachedCollection);
               }
             });
           }
         };

         this.register = function(comment, messageCtrl) {
           var nextKey = latestKey.toString();
           messages[nextKey] = {
             message: messageCtrl
           };
           insertMessageNode($element[0], comment, nextKey);
           comment.$$ngMessageNode = nextKey;
           latestKey++;

           ctrl.reRender();
         };

         this.deregister = function(comment) {
           var key = comment.$$ngMessageNode;
           delete comment.$$ngMessageNode;
           removeMessageNode($element[0], comment, key);
           delete messages[key];
           ctrl.reRender();
         };

         function findPreviousMessage(parent, comment) {
           var prevNode = comment;
           var parentLookup = [];
           while (prevNode && prevNode !== parent) {
             var prevKey = prevNode.$$ngMessageNode;
             if (prevKey && prevKey.length) {
               return messages[prevKey];
             }

             // dive deeper into the DOM and examine its children for any ngMessage
             // comments that may be in an element that appears deeper in the list
             if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) == -1) {
               parentLookup.push(prevNode);
               prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
             } else {
               prevNode = prevNode.previousSibling || prevNode.parentNode;
             }
           }
         }

         function insertMessageNode(parent, comment, key) {
           var messageNode = messages[key];
           if (!ctrl.head) {
             ctrl.head = messageNode;
           } else {
             var match = findPreviousMessage(parent, comment);
             if (match) {
               messageNode.next = match.next;
               match.next = messageNode;
             } else {
               messageNode.next = ctrl.head;
               ctrl.head = messageNode;
             }
           }
         }

         function removeMessageNode(parent, comment, key) {
           var messageNode = messages[key];

           var match = findPreviousMessage(parent, comment);
           if (match) {
             match.next = messageNode.next;
           } else {
             ctrl.head = messageNode.next;
           }
         }
       }]
     };

     function isAttrTruthy(scope, attr) {
      return (isString(attr) && attr.length === 0) || //empty attribute
             truthy(scope.$eval(attr));
     }

     function truthy(val) {
       return isString(val) ? val.length : !!val;
     }
   }])

   /**
    * @ngdoc directive
    * @name ngMessagesInclude
    * @restrict AE
    * @scope
    *
    * @description
    * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template
    * code from a remote template and place the downloaded template code into the exact spot
    * that the ngMessagesInclude directive is placed within the ngMessages container. This allows
    * for a series of pre-defined messages to be reused and also allows for the developer to
    * determine what messages are overridden due to the placement of the ngMessagesInclude directive.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY ng-messages="expression" role="alert">
    *   <ANY ng-messages-include="remoteTplString">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <ng-messages for="expression" role="alert">
    *   <ng-messages-include src="expressionValue1">...</ng-messages-include>
    * </ng-messages>
    * ```
    *
    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
    *
    * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.
    */
   .directive('ngMessagesInclude',
     ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {

     return {
       restrict: 'AE',
       require: '^^ngMessages', // we only require this for validation sake
       link: function($scope, element, attrs) {
         var src = attrs.ngMessagesInclude || attrs.src;
         $templateRequest(src).then(function(html) {
           $compile(html)($scope, function(contents) {
             element.after(contents);

             // the anchor is placed for debugging purposes
             var anchor = jqLite($document[0].createComment(' ngMessagesInclude: ' + src + ' '));
             element.after(anchor);

             // we don't want to pollute the DOM anymore by keeping an empty directive element
             element.remove();
           });
         });
       }
     };
   }])

   /**
    * @ngdoc directive
    * @name ngMessage
    * @restrict AE
    * @scope
    *
    * @description
    * `ngMessage` is a directive with the purpose to show and hide a particular message.
    * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element
    * must be situated since it determines which messages are visible based on the state
    * of the provided key/value map that `ngMessages` listens on.
    *
    * More information about using `ngMessage` can be found in the
    * {@link module:ngMessages `ngMessages` module documentation}.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY ng-messages="expression" role="alert">
    *   <ANY ng-message="stringValue">...</ANY>
    *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <ng-messages for="expression" role="alert">
    *   <ng-message when="stringValue">...</ng-message>
    *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
    * </ng-messages>
    * ```
    *
    * @param {expression} ngMessage|when a string value corresponding to the message key.
    */
  .directive('ngMessage', ngMessageDirectiveFactory('AE'))


   /**
    * @ngdoc directive
    * @name ngMessageExp
    * @restrict AE
    * @scope
    *
    * @description
    * `ngMessageExp` is a directive with the purpose to show and hide a particular message.
    * For `ngMessageExp` to operate, a parent `ngMessages` directive on a parent DOM element
    * must be situated since it determines which messages are visible based on the state
    * of the provided key/value map that `ngMessages` listens on.
    *
    * @usage
    * ```html
    * <!-- using attribute directives -->
    * <ANY ng-messages="expression">
    *   <ANY ng-message-exp="expressionValue">...</ANY>
    * </ANY>
    *
    * <!-- or by using element directives -->
    * <ng-messages for="expression">
    *   <ng-message when-exp="expressionValue">...</ng-message>
    * </ng-messages>
    * ```
    *
    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
    *
    * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.
    */
  .directive('ngMessageExp', ngMessageDirectiveFactory('A'));

function ngMessageDirectiveFactory(restrict) {
  return ['$animate', function($animate) {
    return {
      restrict: 'AE',
      transclude: 'element',
      terminal: true,
      require: '^^ngMessages',
      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
        var commentNode = element[0];

        var records;
        var staticExp = attrs.ngMessage || attrs.when;
        var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
        var assignRecords = function(items) {
          records = items
              ? (isArray(items)
                    ? items
                    : items.split(/[\s,]+/))
              : null;
          ngMessagesCtrl.reRender();
        };

        if (dynamicExp) {
          assignRecords(scope.$eval(dynamicExp));
          scope.$watchCollection(dynamicExp, assignRecords);
        } else {
          assignRecords(staticExp);
        }

        var currentElement, messageCtrl;
        ngMessagesCtrl.register(commentNode, messageCtrl = {
          test: function(name) {
            return contains(records, name);
          },
          attach: function() {
            if (!currentElement) {
              $transclude(scope, function(elm) {
                $animate.enter(elm, null, element);
                currentElement = elm;

                // Each time we attach this node to a message we get a new id that we can match
                // when we are destroying the node later.
                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();

                // in the event that the parent element is destroyed
                // by any other structural directive then it's time
                // to deregister the message from the controller
                currentElement.on('$destroy', function() {
                  if (currentElement && currentElement.$$attachId === $$attachId) {
                    ngMessagesCtrl.deregister(commentNode);
                    messageCtrl.detach();
                  }
                });
              });
            }
          },
          detach: function() {
            if (currentElement) {
              var elm = currentElement;
              currentElement = null;
              $animate.leave(elm);
            }
          }
        });
      }
    };
  }];

  function contains(collection, key) {
    if (collection) {
      return isArray(collection)
          ? collection.indexOf(key) >= 0
          : collection.hasOwnProperty(key);
    }
  }
}


})(window, window.angular);

},{}],17:[function(require,module,exports){
require('./angular-messages');
module.exports = 'ngMessages';

},{"./angular-messages":16}]},{},[12,13,15])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvbW9kdWxlcy9zdGFydC5mb3Jtcy5jb21wb25lbnRzL2VtYWlsLWlucHV0L2VtYWlsLWlucHV0LWRpcmVjdGl2ZS5qcyIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zLmNvbXBvbmVudHMvZW1haWwtaW5wdXQvZW1haWwtaW5wdXQtdGVtcGxhdGUuaHRtbCIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zLmNvbXBvbmVudHMvZW1haWwtaW5wdXQvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9zdGFydC5mb3Jtcy5jb21wb25lbnRzL2luZGV4LmpzIiwiYXBwL21vZHVsZXMvc3RhcnQuZm9ybXMuY29tcG9uZW50cy90ZXh0LWlucHV0L2luZGV4LmpzIiwiYXBwL21vZHVsZXMvc3RhcnQuZm9ybXMuY29tcG9uZW50cy90ZXh0LWlucHV0L3RleHQtaW5wdXQtZGlyZWN0aXZlLmpzIiwiYXBwL21vZHVsZXMvc3RhcnQuZm9ybXMuY29tcG9uZW50cy90ZXh0LWlucHV0L3RleHQtaW5wdXQtdGVtcGxhdGUuaHRtbCIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zLmZpZWxkc2V0cy9pbmRleC5qcyIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zLmZpZWxkc2V0cy9pbnB1dC1yb3cvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9zdGFydC5mb3Jtcy5maWVsZHNldHMvaW5wdXQtcm93L2lucHV0LXJvdy1kaXJlY3RpdmUuanMiLCJhcHAvbW9kdWxlcy9zdGFydC5mb3Jtcy5maWVsZHNldHMvaW5wdXQtcm93L2lucHV0LXJvdy10ZW1wbGF0ZS5odG1sIiwiYXBwL21vZHVsZXMvc3RhcnQuZm9ybXMvaW5kZXguanMiLCJhcHAvbW9kdWxlcy9zdGFydC5mb3Jtcy9yZWdpc3Rlci9pbmRleC5qcyIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zL3JlZ2lzdGVyL3JlZ2lzdGVyLWRpcmVjdGl2ZS5qcyIsImFwcC9tb2R1bGVzL3N0YXJ0LmZvcm1zL3JlZ2lzdGVyL3JlZ2lzdGVyLXRlbXBsYXRlLmh0bWwiLCJub2RlX21vZHVsZXMvYW5ndWxhci1tZXNzYWdlcy9hbmd1bGFyLW1lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXItbWVzc2FnZXMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdxQkE7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiBzdGFydEVtYWlsSW5wdXREaXJlY3RpdmUoKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIGNvbXBvbmVudHNNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuY29tcG9uZW50cy5lbWFpbElucHV0JywgW10pO1xuXHRjb21wb25lbnRzTW9kdWxlLmRpcmVjdGl2ZSgnc3RhcnRFbWFpbElucHV0JywgZW1haWxJbnB1dCk7XG5cblx0ZW1haWxJbnB1dC4kaW5qZWN0ID0gW107XG5cblx0ZnVuY3Rpb24gZW1haWxJbnB1dCgpIHtcblx0XHR2YXIgZGlyZWN0aXZlID0ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFQScsXG5cdFx0XHR0ZW1wbGF0ZTogcmVxdWlyZSgnLi9lbWFpbC1pbnB1dC10ZW1wbGF0ZS5odG1sJyksXG5cdFx0XHRzY29wZToge1xuXHRcdFx0XHRvcHRpb25zOiAnPSdcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIGRpcmVjdGl2ZTtcblx0fVxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG5cXHQ8aW5wdXRcXG5cXHRpZD1cXFwie3sgb3B0aW9ucy5maWVsZElkIH19XFxcIlxcblxcdG5hbWU9XFxcInt7IG9wdGlvbnMuZmllbGRJZCB9fVxcXCJcXG5cXHR0eXBlPVxcXCJlbWFpbFxcXCJcXG5cXHRjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcblxcdG5nLW1vZGVsPVxcXCJvcHRpb25zLmZpZWxkTW9kZWxcXFwiXFxuXFx0cGxhY2Vob2xkZXI9XFxcInt7IG9wdGlvbnMuZmllbGRQbGFjZWhvbGRlciB9fVxcXCJcXG5cXHRuZy1kaXNhYmxlZD1cXFwib3B0aW9ucy5pc0Rpc2FibGVkXFxcIlxcblxcdG5nLXJlcXVpcmVkPVxcXCJvcHRpb25zLmZpZWxkUmVxdWlyZWRcXFwiPlxcblwiO1xuIiwiKGZ1bmN0aW9uIGVtYWlsSW5wdXRJbml0KCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gZGVjbGFyZSB0aGUgY29tcG9uZW50IGFuZ3VsYXIgbW9kdWxlLCB5b3UgY2FuIGluamVjdCBkZXBlbmRlbmNpZXMgaGVyZVxuXHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuY29tcG9uZW50cy5lbWFpbElucHV0JywgW10pO1xuXG5cdC8vIFJlcXVpcmUgeW91ciBjb21wb25lbnRzIGhlcmVcblx0cmVxdWlyZSgnLi9lbWFpbC1pbnB1dC1kaXJlY3RpdmUuanMnKTtcblxufSgpKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBncnVudDogYnJvd3NlcmlmeS1pbXBvcnRzXG4oZnVuY3Rpb24gbW9kdWxlSW5pdF9zdGFydEZvcm1zQ29tcG9uZW50cygpIHtcblxuXHQvLyBBZGQgcmVxdWlyZSBmb3Igb3RoZXIgbW9kdWxlcyBoZXJlXG5cblx0Ly8gR3J1bnQgYnJvd3NlcmlmeS1pbXBvcnRzIHJlcXVpcmUgYWxsIGNvbXBvbmVudHMgd2l0aCBhbiBpbmRleC5qcyBoZXJlXG5cdC8vIFN0YXJ0UmVxdWlyZVxuXHRyZXF1aXJlKCcuL2VtYWlsLWlucHV0Jyk7XG5cdHJlcXVpcmUoJy4vdGV4dC1pbnB1dCcpO1xuXHR2YXIgYW5ndWxhck1vZHVsZURlcGVuZGVuY2llcyA9IFtcInN0YXJ0LmZvcm1zLmNvbXBvbmVudHMuZW1haWxJbnB1dFwiLFwic3RhcnQuZm9ybXMuY29tcG9uZW50cy50ZXh0SW5wdXRcIl07XG5cdC8vIEVuZFJlcXVpcmVcblxuXHQvLyBBZGQgeW91ciBhbmd1bGFyIG1vZHVsZSBkZXBlbmRlbmNpZXMgaGVyZVxuXHQvLyBhbmd1bGFyTW9kdWxlRGVwZW5kZW5jaWVzLnB1c2goJ290aGVyLm1vZHVsZScpO1xuXG5cdHRyeSB7XG5cdFx0Y29uc29sZS5sb2coJ2xvYWRpbmcgbW9kdWxlIHN0YXJ0LmZvcm1zLmNvbXBvbmVudHMnKTtcblx0XHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuY29tcG9uZW50cycsIGFuZ3VsYXJNb2R1bGVEZXBlbmRlbmNpZXMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Y29uc29sZS5sb2coJ3N0YXJ0LmZvcm1zLmNvbXBvbmVudHMgaXMgYWxyZWFkeSBkZWZpbmVkLicpO31cblx0fVxuKSgpO1xuIiwiKGZ1bmN0aW9uIHRleHRJbnB1dEluaXQoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBkZWNsYXJlIHRoZSBjb21wb25lbnQgYW5ndWxhciBtb2R1bGUsIHlvdSBjYW4gaW5qZWN0IGRlcGVuZGVuY2llcyBoZXJlXG5cdGFuZ3VsYXIubW9kdWxlKCdzdGFydC5mb3Jtcy5jb21wb25lbnRzLnRleHRJbnB1dCcsIFtdKTtcblxuXHQvLyBSZXF1aXJlIHlvdXIgY29tcG9uZW50cyBoZXJlXG5cdHJlcXVpcmUoJy4vdGV4dC1pbnB1dC1kaXJlY3RpdmUuanMnKTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiBzdGFydFRleHRJbnB1dERpcmVjdGl2ZSgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgY29tcG9uZW50c01vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdGFydC5mb3Jtcy5jb21wb25lbnRzLnRleHRJbnB1dCcsIFtdKTtcblx0Y29tcG9uZW50c01vZHVsZS5kaXJlY3RpdmUoJ3N0YXJ0VGV4dElucHV0JywgdGV4dElucHV0KTtcblxuXHR0ZXh0SW5wdXQuJGluamVjdCA9IFtdO1xuXG5cdGZ1bmN0aW9uIHRleHRJbnB1dCgpIHtcblx0XHR2YXIgZGlyZWN0aXZlID0ge1xuXHRcdFx0cmVzdHJpY3Q6ICdFQScsXG5cdFx0XHR0ZW1wbGF0ZTogcmVxdWlyZSgnLi90ZXh0LWlucHV0LXRlbXBsYXRlLmh0bWwnKSxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdG9wdGlvbnM6ICc9J1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gZGlyZWN0aXZlO1xuXHR9XG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcblxcdDxpbnB1dFxcblxcdGlkPVxcXCJ7eyBvcHRpb25zLmZpZWxkSWQgfX1cXFwiXFxuXFx0bmFtZT1cXFwie3sgb3B0aW9ucy5maWVsZElkIH19XFxcIlxcblxcdHR5cGU9XFxcInRleHRcXFwiXFxuXFx0Y2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCJcXG5cXHRwbGFjZWhvbGRlcj1cXFwie3sgb3B0aW9ucy5maWVsZFBsYWNlaG9sZGVyIH19XFxcIlxcblxcdG5nLW1vZGVsPVxcXCJvcHRpb25zLmZpZWxkTW9kZWxcXFwiXFxuXFx0bmctZGlzYWJsZWQ9XFxcIm9wdGlvbnMuaXNEaXNhYmxlZFxcXCJcXG5cXHRuZy1yZXF1aXJlZD1cXFwib3B0aW9ucy5maWVsZFJlcXVpcmVkXFxcIj5cXG5cIjtcbiIsIi8vIEdlbmVyYXRlZCBieSBncnVudDogYnJvd3NlcmlmeS1pbXBvcnRzXG4oZnVuY3Rpb24gbW9kdWxlSW5pdF9zdGFydEZvcm1zRmllbGRzZXRzKCkge1xuXG5cdC8vIEFkZCByZXF1aXJlIGZvciBvdGhlciBtb2R1bGVzIGhlcmVcblx0cmVxdWlyZSgnYW5ndWxhci1tZXNzYWdlcycpO1xuXHRyZXF1aXJlKCcuLi9zdGFydC5mb3Jtcy5jb21wb25lbnRzJyk7XG5cblx0Ly8gR3J1bnQgYnJvd3NlcmlmeS1pbXBvcnRzIHJlcXVpcmUgYWxsIGNvbXBvbmVudHMgd2l0aCBhbiBpbmRleC5qcyBoZXJlXG5cdC8vIFN0YXJ0UmVxdWlyZVxuXHRyZXF1aXJlKCcuL2lucHV0LXJvdycpO1xuXHR2YXIgYW5ndWxhck1vZHVsZURlcGVuZGVuY2llcyA9IFtcInN0YXJ0LmZvcm1zLmZpZWxkc2V0cy5pbnB1dFJvd1wiXTtcblx0Ly8gRW5kUmVxdWlyZVxuXG5cdC8vIEFkZCB5b3VyIGFuZ3VsYXIgbW9kdWxlIGRlcGVuZGVuY2llcyBoZXJlXG5cdGFuZ3VsYXJNb2R1bGVEZXBlbmRlbmNpZXMucHVzaCgnbmdNZXNzYWdlcycpO1xuXHRhbmd1bGFyTW9kdWxlRGVwZW5kZW5jaWVzLnB1c2goJ3N0YXJ0LmZvcm1zLmNvbXBvbmVudHMnKTtcblxuXHR0cnkge1xuXHRcdGNvbnNvbGUubG9nKCdsb2FkaW5nIG1vZHVsZSBzdGFydC5mb3Jtcy5maWVsZHNldHMnKTtcblx0XHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuZmllbGRzZXRzJywgYW5ndWxhck1vZHVsZURlcGVuZGVuY2llcyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRjb25zb2xlLmxvZygnc3RhcnQuZm9ybXMuZmllbGRzZXRzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTt9XG5cdH1cbikoKTtcbiIsIihmdW5jdGlvbiBpbnB1dFJvd1RleHRJbml0KCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gZGVjbGFyZSB0aGUgY29tcG9uZW50IGFuZ3VsYXIgbW9kdWxlLCB5b3UgY2FuIGluamVjdCBkZXBlbmRlbmNpZXMgaGVyZVxuXHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuZmllbGRzZXRzLmlucHV0Um93JywgW10pO1xuXG5cdC8vIFJlcXVpcmUgeW91ciBjb21wb25lbnRzIGhlcmVcblx0cmVxdWlyZSgnLi9pbnB1dC1yb3ctZGlyZWN0aXZlLmpzJyk7XG5cbn0oKSk7XG4iLCIoZnVuY3Rpb24gc3RhcnRJbnB1dFJvd1RleHREaXJlY3RpdmUoKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIGNvbXBvbmVudHNNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMuZmllbGRzZXRzLmlucHV0Um93JywgWyAnc3RhcnQuZm9ybXMuY29tcG9uZW50cy50ZXh0SW5wdXQnXSk7XG5cdGNvbXBvbmVudHNNb2R1bGUuZGlyZWN0aXZlKCdzdGFydElucHV0Um93Jywgc3RhcnRJbnB1dFJvdyk7XG5cblx0c3RhcnRJbnB1dFJvdy4kaW5qZWN0ID0gW107XG5cblx0ZnVuY3Rpb24gc3RhcnRJbnB1dFJvdygpIHtcblx0XHR2YXIgZGlyZWN0aXZlID0ge1xuXHRcdFx0dHJhbnNjbHVkZTogdHJ1ZSxcblx0XHRcdHJlc3RyaWN0OiAnRUEnLFxuXHRcdFx0dGVtcGxhdGU6IHJlcXVpcmUoJy4vaW5wdXQtcm93LXRlbXBsYXRlLmh0bWwnKSxcblx0XHRcdHNjb3BlOiB7XG5cdFx0XHRcdGxhYmVsOiAnQCcsXG5cdFx0XHRcdGZpZWxkTW9kZWw6ICc9Jyxcblx0XHRcdFx0ZmllbGRUeXBlOiAnQCcsXG5cdFx0XHRcdGZpZWxkSWQ6ICdAJyxcblx0XHRcdFx0ZmllbGRSZXF1aXJlZDogJz0nLFxuXHRcdFx0XHRmaWVsZFBsYWNlaG9sZGVyOiAnQD8nXG5cdFx0XHR9LFxuXHRcdFx0YmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcblx0XHRcdGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJyRhdHRycycsIGZ1bmN0aW9uKHNjb3BlLCAkYXR0cnMpIHt9XSxcblx0XHRcdGNvbnRyb2xsZXJBczogJ2ZpZWxkQ3RybCdcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGRpcmVjdGl2ZTtcblx0fVxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tIG5nLWZvcm09XFxcImZpZWxkRm9ybVxcXCIgLS0+XFxuPGRpdiBuZy1mb3JtPVxcXCJmaWVsZEZvcm1cXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1idXR0b257JyA6IGJ1dHRvbn1cXFwiIGNsYXNzPVxcXCJpbnB1dC1yb3cgaW5wdXQtcm93LXRleHQge3sgY2xhc3MgfX0gY2xlYXJmaXhcXFwiPlxcblxcblxcdDxkaXYgbmctZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIiBjbGFzcz1cXFwiaW5wdXQtcm93LWxhYmVsIGZvcm0tbGVmdFxcXCI+XFxuXFx0XFx0PGxhYmVsIGNsYXNzPVxcXCJmb3JtLWxhYmVsXFxcIiBmb3I9XFxcInt7IGZpZWxkQ3RybC5maWVsZElkIH19XFxcIj57eyBmaWVsZEN0cmwubGFiZWwgfX08L2xhYmVsPlxcblxcdFxcdDxuZy10cmFuc2NsdWRlPjwvbmctdHJhbnNjbHVkZT5cXG5cXHQ8L2Rpdj5cXG5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJmb3JtLXJpZ2h0XFxcIj5cXG5cXG5cXHRcXHQ8ZGl2IG5nLXN3aXRjaD1cXFwiZmllbGRDdHJsLmZpZWxkVHlwZVxcXCI+XFxuXFx0XFx0XFx0PHN0YXJ0LXRleHQtaW5wdXQgbmctc3dpdGNoLXdoZW49XFxcInRleHRcXFwiIG9wdGlvbnM9XFxcImZpZWxkQ3RybFxcXCI+PC9zdGFydC10ZXh0LWlucHV0PlxcblxcdFxcdFxcdDxzdGFydC1lbWFpbC1pbnB1dCBuZy1zd2l0Y2gtd2hlbj1cXFwiZW1haWxcXFwiIG9wdGlvbnM9XFxcImZpZWxkQ3RybFxcXCI+PC9zdGFydC1lbWFpbC1pbnB1dD5cXG5cXHRcXHQ8L2Rpdj5cXG5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJlcnJvcnNcXFwiIG5nLW1lc3NhZ2VzPVxcXCJmaWVsZEZvcm1bZmllbGRDdHJsLmZpZWxkSWRdLiRkaXJ0eSAmJiBmaWVsZEZvcm1bZmllbGRDdHJsLmZpZWxkSWRdLiRlcnJvclxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcblxcdFxcdFxcdDxkaXYgbmctbWVzc2FnZT1cXFwicmVxdWlyZWRcXFwiPllvdSBkaWQgbm90IGVudGVyIGEgdmFsdWUgZm9yIHRoaXMgZmllbGQ8L2Rpdj5cXG5cXHRcXHRcXHQ8ZGl2IG5nLW1lc3NhZ2U9XFxcImVtYWlsXFxcIj5JdCdzIG5vdCBhIHZhbGlkIGVtYWlsPC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFxuXFx0PC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgZ3J1bnQ6IGJyb3dzZXJpZnktaW1wb3J0c1xuKGZ1bmN0aW9uIG1vZHVsZUluaXRfc3RhcnRGb3JtcygpIHtcblxuXHQvLyBBZGQgcmVxdWlyZSBmb3Igb3RoZXIgbW9kdWxlcyBoZXJlXG5cdHJlcXVpcmUoJ2FuZ3VsYXItbWVzc2FnZXMnKTtcblx0cmVxdWlyZSgnLi4vc3RhcnQuZm9ybXMuZmllbGRzZXRzJyk7XG5cblx0Ly8gcmVxdWlyZSgnLi4vZ3VpLm5nLmNvbXBvbmVudHMnKTtcblxuXHQvLyBHcnVudCBicm93c2VyaWZ5LWltcG9ydHMgcmVxdWlyZSBhbGwgY29tcG9uZW50cyB3aXRoIGFuIGluZGV4LmpzIGhlcmVcblx0Ly8gU3RhcnRSZXF1aXJlXG5cdHJlcXVpcmUoJy4vcmVnaXN0ZXInKTtcblx0dmFyIGFuZ3VsYXJNb2R1bGVEZXBlbmRlbmNpZXMgPSBbXCJzdGFydC5mb3Jtcy5yZWdpc3RlclwiXTtcblx0Ly8gRW5kUmVxdWlyZVxuXG5cdC8vIEFkZCB5b3VyIGFuZ3VsYXIgbW9kdWxlIGRlcGVuZGVuY2llcyBoZXJlXG5cdGFuZ3VsYXJNb2R1bGVEZXBlbmRlbmNpZXMucHVzaCgnbmdNZXNzYWdlcycpO1xuXHRhbmd1bGFyTW9kdWxlRGVwZW5kZW5jaWVzLnB1c2goJ3N0YXJ0LmZvcm1zLmZpZWxkc2V0cycpO1xuXHQvLyBhbmd1bGFyTW9kdWxlRGVwZW5kZW5jaWVzLnB1c2goJ2d1aS5uZy5jb21wb25lbnRzJyk7XG5cblx0dHJ5IHtcblx0XHRjb25zb2xlLmxvZygnbG9hZGluZyBtb2R1bGUgc3RhcnQuZm9ybXMnKTtcblx0XHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMnLCBhbmd1bGFyTW9kdWxlRGVwZW5kZW5jaWVzKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGNvbnNvbGUubG9nKCdzdGFydC5mb3JtcyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7fVxuXHR9XG4pKCk7XG4iLCIoZnVuY3Rpb24gcmVnaXN0ZXJJbml0KCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gZGVjbGFyZSB0aGUgY29tcG9uZW50IGFuZ3VsYXIgbW9kdWxlLCB5b3UgY2FuIGluamVjdCBkZXBlbmRlbmNpZXMgaGVyZVxuXHRhbmd1bGFyLm1vZHVsZSgnc3RhcnQuZm9ybXMucmVnaXN0ZXInLCBbXSk7XG5cblx0Ly8gUmVxdWlyZSB5b3VyIGNvbXBvbmVudHMgaGVyZVxuXHRyZXF1aXJlKCcuL3JlZ2lzdGVyLWRpcmVjdGl2ZS5qcycpO1xuXG59KCkpO1xuIiwiKGZ1bmN0aW9uIHN0YXJ0UmVnaXN0ZXJEaXJlY3RpdmUoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tcG9uZW50c01vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdzdGFydC5mb3Jtcy5yZWdpc3RlcicsIFtdKTtcblx0Y29tcG9uZW50c01vZHVsZS5kaXJlY3RpdmUoJ3N0YXJ0UmVnaXN0ZXInLCByZWdpc3Rlcik7XG5cblx0cmVnaXN0ZXIuJGluamVjdCA9IFtdO1xuXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuXHRcdHZhciBkaXJlY3RpdmUgPSB7XG5cdFx0XHRyZXN0cmljdDogJ0VBJyxcblx0XHRcdHRlbXBsYXRlOiByZXF1aXJlKCcuL3JlZ2lzdGVyLXRlbXBsYXRlLmh0bWwnKSxcblx0XHRcdHNjb3BlOiB7fSxcblx0XHRcdGNvbnRyb2xsZXIgOiBbJyRzY29wZScsICckYXR0cnMnLCBmdW5jdGlvbihzY29wZSwgJGF0dHJzKSB7XG5cdFx0XHRcdHNjb3BlLmZvcm1EYXRhID0ge307XG5cblx0XHRcdFx0dGhpcy5oYW5kbGVTdWJtaXQgPSBmdW5jdGlvbih2YWxpZCwgZm9ybURhdGEpIHtcblx0XHRcdFx0XHRpZiAodmFsaWQpIHtcblx0XHRcdFx0XHRcdHNjb3BlLiRldmFsKCRhdHRycy5vblZhbGlkU3VibWl0KTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdkYXRhIHN1Ym1pdHRlZDonKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBmb3JtRGF0YSApO1xuXHRcdFx0XHRcdFx0c2NvcGUuZGF0YVN1Ym1pdHRlZCA9IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ2Zvcm0gaW52YWxpZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0fV0sXG5cdFx0XHRjb250cm9sbGVyQXM6ICdjdHJsJyxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGRpcmVjdGl2ZTtcblx0fVxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJzdGFydC1yZWdpc3RlclxcXCI+XFxuXFxuXFx0PGgyIGNsYXNzPVxcXCJib2R5LWZvbnRcXFwiPlJlZ2lzdGVyIGZvcm08L2gyPlxcblxcdDxmb3JtIG5hbWU9XFxcInJlZ2lzdGVyRm9ybVxcXCIgY2xhc3M9XFxcInN0YXJ0LXJlZ2lzdGVyLWZvcm1cXFwiIG5nLXN1Ym1pdD1cXFwiY3RybC5oYW5kbGVTdWJtaXQocmVnaXN0ZXJGb3JtLiR2YWxpZCwgZm9ybURhdGEpXFxcIiBub3ZhbGlkYXRlPlxcblxcblxcdFxcdDxwIG5nLWlmPVxcXCJyZWdpc3RlckZvcm0uJHN1Ym1pdHRlZCAmJiByZWdpc3RlckZvcm0uJGVycm9yXFxcIj5cXG5cXHRcXHRcXHRQbGVhc2UgZml4IHRoZSBlcnJvcnMgaW4geW91ciBmb3JtOlxcblxcdFxcdDwvcD5cXG5cXG5cXHRcXHQ8c3RhcnQtaW5wdXQtcm93XFxuXFx0XFx0bGFiZWw9XFxcIkZpcnN0IG5hbWVcXFwiXFxuXFx0XFx0ZmllbGQtbW9kZWw9XFxcImZvcm1EYXRhLmZpcnN0TmFtZVxcXCJcXG5cXHRcXHRmaWVsZC10eXBlPVxcXCJ0ZXh0XFxcIlxcblxcdFxcdGZpZWxkLWlkPVxcXCJyZWdpc3RlckZvcm0tZmlyc3ROYW1lXFxcIlxcblxcdFxcdGZpZWxkLXBsYWNlaG9sZGVyPVxcXCJlbnRlciB5b3VyIGZpcnN0IG5hbWVcXFwiXFxuXFx0XFx0ZmllbGQtcmVxdWlyZWQ9XFxcInRydWVcXFwiPlxcblxcdFxcdDwhLS0gPGd1aS1wb3BvdmVyPjwvZ3VpLXBvcG92ZXI+IC0tPlxcblxcdFxcdDwvc3RhcnQtaW5wdXQtcm93PlxcblxcblxcdFxcdDxzdGFydC1pbnB1dC1yb3dcXG5cXHRcXHRsYWJlbD1cXFwiTGFzdCBuYW1lXFxcIlxcblxcdFxcdGZpZWxkLW1vZGVsPVxcXCJmb3JtRGF0YS5sYXN0TmFtZVxcXCJcXG5cXHRcXHRmaWVsZC10eXBlPVxcXCJ0ZXh0XFxcIlxcblxcdFxcdGZpZWxkLWlkPVxcXCJyZWdpc3RlckZvcm0tbGFzdE5hbWVcXFwiXFxuXFx0XFx0ZmllbGQtcmVxdWlyZWQ9XFxcInRydWVcXFwiPlxcblxcdFxcdDwvc3RhcnQtaW5wdXQtcm93PlxcblxcblxcdFxcdDxzdGFydC1pbnB1dC1yb3dcXG5cXHRcXHRsYWJlbD1cXFwiRW1haWxcXFwiXFxuXFx0XFx0ZmllbGQtbW9kZWw9XFxcImZvcm1EYXRhLmVtYWlsXFxcIlxcblxcdFxcdGZpZWxkLXR5cGU9XFxcImVtYWlsXFxcIlxcblxcdFxcdGZpZWxkLWlkPVxcXCJyZWdpc3RlckZvcm0tZW1haWxcXFwiXFxuXFx0XFx0ZmllbGQtcmVxdWlyZWQ9XFxcInRydWVcXFwiPlxcblxcdFxcdDwvc3RhcnQtaW5wdXQtcm93PlxcblxcblxcdFxcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBzdGFydC1yZWdpc3Rlci1zdWJtaXRcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcblxcblxcdDwvZm9ybT5cXG5cXG5cXHQ8ZGl2PlxcblxcdFxcdDxoMz5cXG5cXHRcXHRcXHRkYXRhIHN1Ym1pdGVkXFxuXFx0XFx0PC9oMz5cXG5cXHRcXHR7eyBkYXRhU3VibWl0dGVkIH19XFxuXFx0PC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS40LjdcbiAqIChjKSAyMDEwLTIwMTUgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4vLyB0aGlzIGNvZGUgaXMgaW4gdGhlIGNvcmUsIGJ1dCBub3QgaW4gYW5ndWxhci1tZXNzYWdlcy5qc1xudmFyIGlzQXJyYXkgPSBhbmd1bGFyLmlzQXJyYXk7XG52YXIgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaDtcbnZhciBpc1N0cmluZyA9IGFuZ3VsYXIuaXNTdHJpbmc7XG52YXIganFMaXRlID0gYW5ndWxhci5lbGVtZW50O1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuLyoqXG4gKiBAbmdkb2MgbW9kdWxlXG4gKiBAbmFtZSBuZ01lc3NhZ2VzXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgYG5nTWVzc2FnZXNgIG1vZHVsZSBwcm92aWRlcyBlbmhhbmNlZCBzdXBwb3J0IGZvciBkaXNwbGF5aW5nIG1lc3NhZ2VzIHdpdGhpbiB0ZW1wbGF0ZXNcbiAqICh0eXBpY2FsbHkgd2l0aGluIGZvcm1zIG9yIHdoZW4gcmVuZGVyaW5nIG1lc3NhZ2Ugb2JqZWN0cyB0aGF0IHJldHVybiBrZXkvdmFsdWUgZGF0YSkuXG4gKiBJbnN0ZWFkIG9mIHJlbHlpbmcgb24gSmF2YVNjcmlwdCBjb2RlIGFuZC9vciBjb21wbGV4IG5nLWlmIHN0YXRlbWVudHMgd2l0aGluIHlvdXIgZm9ybSB0ZW1wbGF0ZSB0b1xuICogc2hvdyBhbmQgaGlkZSBlcnJvciBtZXNzYWdlcyBzcGVjaWZpYyB0byB0aGUgc3RhdGUgb2YgYW4gaW5wdXQgZmllbGQsIHRoZSBgbmdNZXNzYWdlc2AgYW5kXG4gKiBgbmdNZXNzYWdlYCBkaXJlY3RpdmVzIGFyZSBkZXNpZ25lZCB0byBoYW5kbGUgdGhlIGNvbXBsZXhpdHksIGluaGVyaXRhbmNlIGFuZCBwcmlvcml0eVxuICogc2VxdWVuY2luZyBiYXNlZCBvbiB0aGUgb3JkZXIgb2YgaG93IHRoZSBtZXNzYWdlcyBhcmUgZGVmaW5lZCBpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogQ3VycmVudGx5LCB0aGUgbmdNZXNzYWdlcyBtb2R1bGUgb25seSBjb250YWlucyB0aGUgY29kZSBmb3IgdGhlIGBuZ01lc3NhZ2VzYCwgYG5nTWVzc2FnZXNJbmNsdWRlYFxuICogYG5nTWVzc2FnZWAgYW5kIGBuZ01lc3NhZ2VFeHBgIGRpcmVjdGl2ZXMuXG4gKlxuICogIyBVc2FnZVxuICogVGhlIGBuZ01lc3NhZ2VzYCBkaXJlY3RpdmUgbGlzdGVucyBvbiBhIGtleS92YWx1ZSBjb2xsZWN0aW9uIHdoaWNoIGlzIHNldCBvbiB0aGUgbmdNZXNzYWdlcyBhdHRyaWJ1dGUuXG4gKiBTaW5jZSB0aGUge0BsaW5rIG5nTW9kZWwgbmdNb2RlbH0gZGlyZWN0aXZlIGV4cG9zZXMgYW4gYCRlcnJvcmAgb2JqZWN0LCB0aGlzIGVycm9yIG9iamVjdCBjYW4gYmVcbiAqIHVzZWQgd2l0aCBgbmdNZXNzYWdlc2AgdG8gZGlzcGxheSBjb250cm9sIGVycm9yIG1lc3NhZ2VzIGluIGFuIGVhc2llciB3YXkgdGhhbiB3aXRoIGp1c3QgcmVndWxhciBhbmd1bGFyXG4gKiB0ZW1wbGF0ZSBkaXJlY3RpdmVzLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAqICAgPGxhYmVsPlxuICogICAgIEVudGVyIHRleHQ6XG4gKiAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJmaWVsZFwiIG5hbWU9XCJteUZpZWxkXCIgcmVxdWlyZWQgbWlubGVuZ3RoPVwiNVwiIC8+XG4gKiAgIDwvbGFiZWw+XG4gKiAgIDxkaXYgbmctbWVzc2FnZXM9XCJteUZvcm0ubXlGaWVsZC4kZXJyb3JcIiByb2xlPVwiYWxlcnRcIj5cbiAqICAgICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPllvdSBkaWQgbm90IGVudGVyIGEgZmllbGQ8L2Rpdj5cbiAqICAgICA8ZGl2IG5nLW1lc3NhZ2U9XCJtaW5sZW5ndGgsIG1heGxlbmd0aFwiPlxuICogICAgICAgWW91ciBlbWFpbCBtdXN0IGJlIGJldHdlZW4gNSBhbmQgMTAwIGNoYXJhY3RlcnMgbG9uZ1xuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqIDwvZm9ybT5cbiAqIGBgYFxuICpcbiAqIE5vdyB3aGF0ZXZlciBrZXkvdmFsdWUgZW50cmllcyBhcmUgcHJlc2VudCB3aXRoaW4gdGhlIHByb3ZpZGVkIG9iamVjdCAoaW4gdGhpcyBjYXNlIGAkZXJyb3JgKSB0aGVuXG4gKiB0aGUgbmdNZXNzYWdlcyBkaXJlY3RpdmUgd2lsbCByZW5kZXIgdGhlIGlubmVyIGZpcnN0IG5nTWVzc2FnZSBkaXJlY3RpdmUgKGRlcGVuZGluZyBpZiB0aGUga2V5IHZhbHVlc1xuICogbWF0Y2ggdGhlIGF0dHJpYnV0ZSB2YWx1ZSBwcmVzZW50IG9uIGVhY2ggbmdNZXNzYWdlIGRpcmVjdGl2ZSkuIEluIG90aGVyIHdvcmRzLCBpZiB5b3VyIGVycm9yc1xuICogb2JqZWN0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgZGF0YTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiA8IS0tIGtlZXAgaW4gbWluZCB0aGF0IG5nTW9kZWwgYXV0b21hdGljYWxseSBzZXRzIHRoZXNlIGVycm9yIGZsYWdzIC0tPlxuICogbXlGaWVsZC4kZXJyb3IgPSB7IG1pbmxlbmd0aCA6IHRydWUsIHJlcXVpcmVkIDogdHJ1ZSB9O1xuICogYGBgXG4gKlxuICogVGhlbiB0aGUgYHJlcXVpcmVkYCBtZXNzYWdlIHdpbGwgYmUgZGlzcGxheWVkIGZpcnN0LiBXaGVuIHJlcXVpcmVkIGlzIGZhbHNlIHRoZW4gdGhlIGBtaW5sZW5ndGhgIG1lc3NhZ2VcbiAqIHdpbGwgYmUgZGlzcGxheWVkIHJpZ2h0IGFmdGVyIChzaW5jZSB0aGVzZSBtZXNzYWdlcyBhcmUgb3JkZXJlZCB0aGlzIHdheSBpbiB0aGUgdGVtcGxhdGUgSFRNTCBjb2RlKS5cbiAqIFRoZSBwcmlvcml0aXphdGlvbiBvZiBlYWNoIG1lc3NhZ2UgaXMgZGV0ZXJtaW5lZCBieSB3aGF0IG9yZGVyIHRoZXkncmUgcHJlc2VudCBpbiB0aGUgRE9NLlxuICogVGhlcmVmb3JlLCBpbnN0ZWFkIG9mIGhhdmluZyBjdXN0b20gSmF2YVNjcmlwdCBjb2RlIGRldGVybWluZSB0aGUgcHJpb3JpdHkgb2Ygd2hhdCBlcnJvcnMgYXJlXG4gKiBwcmVzZW50IGJlZm9yZSBvdGhlcnMsIHRoZSBwcmVzZW50YXRpb24gb2YgdGhlIGVycm9ycyBhcmUgaGFuZGxlZCB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIG5nTWVzc2FnZXMgd2lsbCBvbmx5IGRpc3BsYXkgb25lIGVycm9yIGF0IGEgdGltZS4gSG93ZXZlciwgaWYgeW91IHdpc2ggdG8gZGlzcGxheSBhbGxcbiAqIG1lc3NhZ2VzIHRoZW4gdGhlIGBuZy1tZXNzYWdlcy1tdWx0aXBsZWAgYXR0cmlidXRlIGZsYWcgY2FuIGJlIHVzZWQgb24gdGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGVcbiAqIG5nTWVzc2FnZXMgZGlyZWN0aXZlIHRvIG1ha2UgdGhpcyBoYXBwZW4uXG4gKlxuICogYGBgaHRtbFxuICogPCEtLSBhdHRyaWJ1dGUtc3R5bGUgdXNhZ2UgLS0+XG4gKiA8ZGl2IG5nLW1lc3NhZ2VzPVwibXlGb3JtLm15RmllbGQuJGVycm9yXCIgbmctbWVzc2FnZXMtbXVsdGlwbGU+Li4uPC9kaXY+XG4gKlxuICogPCEtLSBlbGVtZW50LXN0eWxlIHVzYWdlIC0tPlxuICogPG5nLW1lc3NhZ2VzIGZvcj1cIm15Rm9ybS5teUZpZWxkLiRlcnJvclwiIG11bHRpcGxlPi4uLjwvbmctbWVzc2FnZXM+XG4gKiBgYGBcbiAqXG4gKiAjIyBSZXVzaW5nIGFuZCBPdmVycmlkaW5nIE1lc3NhZ2VzXG4gKiBJbiBhZGRpdGlvbiB0byBwcmlvcml0aXphdGlvbiwgbmdNZXNzYWdlcyBhbHNvIGFsbG93cyBmb3IgaW5jbHVkaW5nIG1lc3NhZ2VzIGZyb20gYSByZW1vdGUgb3IgYW4gaW5saW5lXG4gKiB0ZW1wbGF0ZS4gVGhpcyBhbGxvd3MgZm9yIGdlbmVyaWMgY29sbGVjdGlvbiBvZiBtZXNzYWdlcyB0byBiZSByZXVzZWQgYWNyb3NzIG11bHRpcGxlIHBhcnRzIG9mIGFuXG4gKiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBgYGBodG1sXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCIgaWQ9XCJlcnJvci1tZXNzYWdlc1wiPlxuICogICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPlRoaXMgZmllbGQgaXMgcmVxdWlyZWQ8L2Rpdj5cbiAqICAgPGRpdiBuZy1tZXNzYWdlPVwibWlubGVuZ3RoXCI+VGhpcyBmaWVsZCBpcyB0b28gc2hvcnQ8L2Rpdj5cbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxkaXYgbmctbWVzc2FnZXM9XCJteUZvcm0ubXlGaWVsZC4kZXJyb3JcIiByb2xlPVwiYWxlcnRcIj5cbiAqICAgPGRpdiBuZy1tZXNzYWdlcy1pbmNsdWRlPVwiZXJyb3ItbWVzc2FnZXNcIj48L2Rpdj5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogSG93ZXZlciwgaW5jbHVkaW5nIGdlbmVyaWMgbWVzc2FnZXMgbWF5IG5vdCBiZSB1c2VmdWwgZW5vdWdoIHRvIG1hdGNoIGFsbCBpbnB1dCBmaWVsZHMsIHRoZXJlZm9yZSxcbiAqIGBuZ01lc3NhZ2VzYCBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byBvdmVycmlkZSBtZXNzYWdlcyBkZWZpbmVkIGluIHRoZSByZW1vdGUgdGVtcGxhdGUgYnkgcmVkZWZpbmluZ1xuICogdGhlbSB3aXRoaW4gdGhlIGRpcmVjdGl2ZSBjb250YWluZXIuXG4gKlxuICogYGBgaHRtbFxuICogPCEtLSBhIGdlbmVyaWMgdGVtcGxhdGUgb2YgZXJyb3IgbWVzc2FnZXMga25vd24gYXMgXCJteS1jdXN0b20tbWVzc2FnZXNcIiAtLT5cbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIiBpZD1cIm15LWN1c3RvbS1tZXNzYWdlc1wiPlxuICogICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPlRoaXMgZmllbGQgaXMgcmVxdWlyZWQ8L2Rpdj5cbiAqICAgPGRpdiBuZy1tZXNzYWdlPVwibWlubGVuZ3RoXCI+VGhpcyBmaWVsZCBpcyB0b28gc2hvcnQ8L2Rpdj5cbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAqICAgPGxhYmVsPlxuICogICAgIEVtYWlsIGFkZHJlc3NcbiAqICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCJcbiAqICAgICAgICAgICAgaWQ9XCJlbWFpbFwiXG4gKiAgICAgICAgICAgIG5hbWU9XCJteUVtYWlsXCJcbiAqICAgICAgICAgICAgbmctbW9kZWw9XCJlbWFpbFwiXG4gKiAgICAgICAgICAgIG1pbmxlbmd0aD1cIjVcIlxuICogICAgICAgICAgICByZXF1aXJlZCAvPlxuICogICA8L2xhYmVsPlxuICogICA8IS0tIGFueSBuZy1tZXNzYWdlIGVsZW1lbnRzIHRoYXQgYXBwZWFyIEJFRk9SRSB0aGUgbmctbWVzc2FnZXMtaW5jbHVkZSB3aWxsXG4gKiAgICAgICAgb3ZlcnJpZGUgdGhlIG1lc3NhZ2VzIHByZXNlbnQgaW4gdGhlIG5nLW1lc3NhZ2VzLWluY2x1ZGUgdGVtcGxhdGUgLS0+XG4gKiAgIDxkaXYgbmctbWVzc2FnZXM9XCJteUZvcm0ubXlFbWFpbC4kZXJyb3JcIiByb2xlPVwiYWxlcnRcIj5cbiAqICAgICA8IS0tIHRoaXMgcmVxdWlyZWQgbWVzc2FnZSBoYXMgb3ZlcnJpZGRlbiB0aGUgdGVtcGxhdGUgbWVzc2FnZSAtLT5cbiAqICAgICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPllvdSBkaWQgbm90IGVudGVyIHlvdXIgZW1haWwgYWRkcmVzczwvZGl2PlxuICpcbiAqICAgICA8IS0tIHRoaXMgaXMgYSBicmFuZCBuZXcgbWVzc2FnZSBhbmQgd2lsbCBhcHBlYXIgbGFzdCBpbiB0aGUgcHJpb3JpdGl6YXRpb24gLS0+XG4gKiAgICAgPGRpdiBuZy1tZXNzYWdlPVwiZW1haWxcIj5Zb3VyIGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZDwvZGl2PlxuICpcbiAqICAgICA8IS0tIGFuZCBoZXJlIGFyZSB0aGUgZ2VuZXJpYyBlcnJvciBtZXNzYWdlcyAtLT5cbiAqICAgICA8ZGl2IG5nLW1lc3NhZ2VzLWluY2x1ZGU9XCJteS1jdXN0b20tbWVzc2FnZXNcIj48L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiA8L2Zvcm0+XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBIVE1MIGNvZGUgYWJvdmUgdGhlIG1lc3NhZ2UgdGhhdCBpcyBzZXQgb24gcmVxdWlyZWQgd2lsbCBvdmVycmlkZSB0aGUgY29ycmVzcG9uZGluZ1xuICogcmVxdWlyZWQgbWVzc2FnZSBkZWZpbmVkIHdpdGhpbiB0aGUgcmVtb3RlIHRlbXBsYXRlLiBUaGVyZWZvcmUsIHdpdGggcGFydGljdWxhciBpbnB1dCBmaWVsZHMgKHN1Y2hcbiAqIGVtYWlsIGFkZHJlc3NlcywgZGF0ZSBmaWVsZHMsIGF1dG9jb21wbGV0ZSBpbnB1dHMsIGV0Yy4uLiksIHNwZWNpYWxpemVkIGVycm9yIG1lc3NhZ2VzIGNhbiBiZSBhcHBsaWVkXG4gKiB3aGlsZSBtb3JlIGdlbmVyaWMgbWVzc2FnZXMgY2FuIGJlIHVzZWQgdG8gaGFuZGxlIG90aGVyLCBtb3JlIGdlbmVyYWwgaW5wdXQgZXJyb3JzLlxuICpcbiAqICMjIER5bmFtaWMgTWVzc2FnaW5nXG4gKiBuZ01lc3NhZ2VzIGFsc28gc3VwcG9ydHMgdXNpbmcgZXhwcmVzc2lvbnMgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGtleSB2YWx1ZXMuIFVzaW5nIGFycmF5cyBhbmRcbiAqIHJlcGVhdGVycyB0byBsaXN0IG1lc3NhZ2VzIGlzIGFsc28gc3VwcG9ydGVkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIGNvZGUgYmVsb3cgd2lsbCBiZSBhYmxlIHRvXG4gKiBmdWxseSBhZGFwdCBpdHNlbGYgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIG1lc3NhZ2Ugd2hlbiBhbnkgb2YgdGhlIGV4cHJlc3Npb24gZGF0YSBjaGFuZ2VzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAqICAgPGxhYmVsPlxuICogICAgIEVtYWlsIGFkZHJlc3NcbiAqICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCJcbiAqICAgICAgICAgICAgbmFtZT1cIm15RW1haWxcIlxuICogICAgICAgICAgICBuZy1tb2RlbD1cImVtYWlsXCJcbiAqICAgICAgICAgICAgbWlubGVuZ3RoPVwiNVwiXG4gKiAgICAgICAgICAgIHJlcXVpcmVkIC8+XG4gKiAgIDwvbGFiZWw+XG4gKiAgIDxkaXYgbmctbWVzc2FnZXM9XCJteUZvcm0ubXlFbWFpbC4kZXJyb3JcIiByb2xlPVwiYWxlcnRcIj5cbiAqICAgICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPllvdSBkaWQgbm90IGVudGVyIHlvdXIgZW1haWwgYWRkcmVzczwvZGl2PlxuICogICAgIDxkaXYgbmctcmVwZWF0PVwiZXJyb3JNZXNzYWdlIGluIGVycm9yTWVzc2FnZXNcIj5cbiAqICAgICAgIDwhLS0gdXNlIG5nLW1lc3NhZ2UtZXhwIGZvciBhIG1lc3NhZ2Ugd2hvc2Uga2V5IGlzIGdpdmVuIGJ5IGFuIGV4cHJlc3Npb24gLS0+XG4gKiAgICAgICA8ZGl2IG5nLW1lc3NhZ2UtZXhwPVwiZXJyb3JNZXNzYWdlLnR5cGVcIj57eyBlcnJvck1lc3NhZ2UudGV4dCB9fTwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqIDwvZm9ybT5cbiAqIGBgYFxuICpcbiAqIFRoZSBgZXJyb3JNZXNzYWdlLnR5cGVgIGV4cHJlc3Npb24gY2FuIGJlIGEgc3RyaW5nIHZhbHVlIG9yIGl0IGNhbiBiZSBhbiBhcnJheSBzb1xuICogdGhhdCBtdWx0aXBsZSBlcnJvcnMgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSBlcnJvciBtZXNzYWdlOlxuICpcbiAqIGBgYGh0bWxcbiAqICAgPGxhYmVsPlxuICogICAgIEVtYWlsIGFkZHJlc3NcbiAqICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCJcbiAqICAgICAgICAgICAgbmctbW9kZWw9XCJkYXRhLmVtYWlsXCJcbiAqICAgICAgICAgICAgbmFtZT1cIm15RW1haWxcIlxuICogICAgICAgICAgICBuZy1taW5sZW5ndGg9XCI1XCJcbiAqICAgICAgICAgICAgbmctbWF4bGVuZ3RoPVwiMTAwXCJcbiAqICAgICAgICAgICAgcmVxdWlyZWQgLz5cbiAqICAgPC9sYWJlbD5cbiAqICAgPGRpdiBuZy1tZXNzYWdlcz1cIm15Rm9ybS5teUVtYWlsLiRlcnJvclwiIHJvbGU9XCJhbGVydFwiPlxuICogICAgIDxkaXYgbmctbWVzc2FnZS1leHA9XCIncmVxdWlyZWQnXCI+WW91IGRpZCBub3QgZW50ZXIgeW91ciBlbWFpbCBhZGRyZXNzPC9kaXY+XG4gKiAgICAgPGRpdiBuZy1tZXNzYWdlLWV4cD1cIlsnbWlubGVuZ3RoJywgJ21heGxlbmd0aCddXCI+XG4gKiAgICAgICBZb3VyIGVtYWlsIG11c3QgYmUgYmV0d2VlbiA1IGFuZCAxMDAgY2hhcmFjdGVycyBsb25nXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogYGBgXG4gKlxuICogRmVlbCBmcmVlIHRvIHVzZSBvdGhlciBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgc3VjaCBhcyBuZy1pZiBhbmQgbmctc3dpdGNoIHRvIGZ1cnRoZXIgY29udHJvbFxuICogd2hhdCBtZXNzYWdlcyBhcmUgYWN0aXZlIGFuZCB3aGVuLiBCZSBjYXJlZnVsLCBpZiB5b3UgcGxhY2UgbmctbWVzc2FnZSBvbiB0aGUgc2FtZSBlbGVtZW50XG4gKiBhcyB0aGVzZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMsIEFuZ3VsYXIgbWF5IG5vdCBiZSBhYmxlIHRvIGRldGVybWluZSBpZiBhIG1lc3NhZ2UgaXMgYWN0aXZlXG4gKiBvciBub3QuIFRoZXJlZm9yZSBpdCBpcyBiZXN0IHRvIHBsYWNlIHRoZSBuZy1tZXNzYWdlIG9uIGEgY2hpbGQgZWxlbWVudCBvZiB0aGUgc3RydWN0dXJhbFxuICogZGlyZWN0aXZlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctbWVzc2FnZXM9XCJteUZvcm0ubXlFbWFpbC4kZXJyb3JcIiByb2xlPVwiYWxlcnRcIj5cbiAqICAgPGRpdiBuZy1pZj1cInNob3dSZXF1aXJlZEVycm9yXCI+XG4gKiAgICAgPGRpdiBuZy1tZXNzYWdlPVwicmVxdWlyZWRcIj5QbGVhc2UgZW50ZXIgc29tZXRoaW5nPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiAjIyBBbmltYXRpb25zXG4gKiBJZiB0aGUgYG5nQW5pbWF0ZWAgbW9kdWxlIGlzIGFjdGl2ZSB3aXRoaW4gdGhlIGFwcGxpY2F0aW9uIHRoZW4gdGhlIGBuZ01lc3NhZ2VzYCwgYG5nTWVzc2FnZWAgYW5kXG4gKiBgbmdNZXNzYWdlRXhwYCBkaXJlY3RpdmVzIHdpbGwgdHJpZ2dlciBhbmltYXRpb25zIHdoZW5ldmVyIGFueSBtZXNzYWdlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbVxuICogdGhlIERPTSBieSB0aGUgYG5nTWVzc2FnZXNgIGRpcmVjdGl2ZS5cbiAqXG4gKiBXaGVuZXZlciB0aGUgYG5nTWVzc2FnZXNgIGRpcmVjdGl2ZSBjb250YWlucyBvbmUgb3IgbW9yZSB2aXNpYmxlIG1lc3NhZ2VzIHRoZW4gdGhlIGAubmctYWN0aXZlYCBDU1NcbiAqIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQuIFRoZSBgLm5nLWluYWN0aXZlYCBDU1MgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlcmUgYXJlIG5vXG4gKiBtZXNzYWdlcyBwcmVzZW50LiBUaGVyZWZvcmUsIENTUyB0cmFuc2l0aW9ucyBhbmQga2V5ZnJhbWVzIGFzIHdlbGwgYXMgSmF2YVNjcmlwdCBhbmltYXRpb25zIGNhblxuICogaG9vayBpbnRvIHRoZSBhbmltYXRpb25zIHdoZW5ldmVyIHRoZXNlIGNsYXNzZXMgYXJlIGFkZGVkL3JlbW92ZWQuXG4gKlxuICogTGV0J3Mgc2F5IHRoYXQgb3VyIEhUTUwgY29kZSBmb3Igb3VyIG1lc3NhZ2VzIGNvbnRhaW5lciBsb29rcyBsaWtlIHNvOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctbWVzc2FnZXM9XCJteU1lc3NhZ2VzXCIgY2xhc3M9XCJteS1tZXNzYWdlc1wiIHJvbGU9XCJhbGVydFwiPlxuICogICA8ZGl2IG5nLW1lc3NhZ2U9XCJhbGVydFwiIGNsYXNzPVwic29tZS1tZXNzYWdlXCI+Li4uPC9kaXY+XG4gKiAgIDxkaXYgbmctbWVzc2FnZT1cImZhaWxcIiBjbGFzcz1cInNvbWUtbWVzc2FnZVwiPi4uLjwvZGl2PlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBUaGVuIHRoZSBDU1MgYW5pbWF0aW9uIGNvZGUgZm9yIHRoZSBtZXNzYWdlIGNvbnRhaW5lciBsb29rcyBsaWtlIHNvOlxuICpcbiAqIGBgYGNzc1xuICogLm15LW1lc3NhZ2VzIHtcbiAqICAgdHJhbnNpdGlvbjoxcyBsaW5lYXIgYWxsO1xuICogfVxuICogLm15LW1lc3NhZ2VzLm5nLWFjdGl2ZSB7XG4gKiAgIC8vIG1lc3NhZ2VzIGFyZSB2aXNpYmxlXG4gKiB9XG4gKiAubXktbWVzc2FnZXMubmctaW5hY3RpdmUge1xuICogICAvLyBtZXNzYWdlcyBhcmUgaGlkZGVuXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuZXZlciBhbiBpbm5lciBtZXNzYWdlIGlzIGF0dGFjaGVkIChiZWNvbWVzIHZpc2libGUpIG9yIHJlbW92ZWQgKGJlY29tZXMgaGlkZGVuKSB0aGVuIHRoZSBlbnRlclxuICogYW5kIGxlYXZlIGFuaW1hdGlvbiBpcyB0cmlnZ2VyZWQgZm9yIGVhY2ggcGFydGljdWxhciBlbGVtZW50IGJvdW5kIHRvIHRoZSBgbmdNZXNzYWdlYCBkaXJlY3RpdmUuXG4gKlxuICogVGhlcmVmb3JlLCB0aGUgQ1NTIGNvZGUgZm9yIHRoZSBpbm5lciBtZXNzYWdlcyBsb29rcyBsaWtlIHNvOlxuICpcbiAqIGBgYGNzc1xuICogLnNvbWUtbWVzc2FnZSB7XG4gKiAgIHRyYW5zaXRpb246MXMgbGluZWFyIGFsbDtcbiAqIH1cbiAqXG4gKiAuc29tZS1tZXNzYWdlLm5nLWVudGVyIHt9XG4gKiAuc29tZS1tZXNzYWdlLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7fVxuICpcbiAqIC5zb21lLW1lc3NhZ2UubmctbGVhdmUge31cbiAqIC5zb21lLW1lc3NhZ2UubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHt9XG4gKiBgYGBcbiAqXG4gKiB7QGxpbmsgbmdBbmltYXRlIENsaWNrIGhlcmV9IHRvIGxlYXJuIGhvdyB0byB1c2UgSmF2YVNjcmlwdCBhbmltYXRpb25zIG9yIHRvIGxlYXJuIG1vcmUgYWJvdXQgbmdBbmltYXRlLlxuICovXG5hbmd1bGFyLm1vZHVsZSgnbmdNZXNzYWdlcycsIFtdKVxuXG4gICAvKipcbiAgICAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAgICAqIEBtb2R1bGUgbmdNZXNzYWdlc1xuICAgICogQG5hbWUgbmdNZXNzYWdlc1xuICAgICogQHJlc3RyaWN0IEFFXG4gICAgKlxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiBgbmdNZXNzYWdlc2AgaXMgYSBkaXJlY3RpdmUgdGhhdCBpcyBkZXNpZ25lZCB0byBzaG93IGFuZCBoaWRlIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBzdGF0ZVxuICAgICogb2YgYSBrZXkvdmFsdWUgb2JqZWN0IHRoYXQgaXQgbGlzdGVucyBvbi4gVGhlIGRpcmVjdGl2ZSBpdHNlbGYgY29tcGxlbWVudHMgZXJyb3IgbWVzc2FnZVxuICAgICogcmVwb3J0aW5nIHdpdGggdGhlIGBuZ01vZGVsYCAkZXJyb3Igb2JqZWN0ICh3aGljaCBzdG9yZXMgYSBrZXkvdmFsdWUgc3RhdGUgb2YgdmFsaWRhdGlvbiBlcnJvcnMpLlxuICAgICpcbiAgICAqIGBuZ01lc3NhZ2VzYCBtYW5hZ2VzIHRoZSBzdGF0ZSBvZiBpbnRlcm5hbCBtZXNzYWdlcyB3aXRoaW4gaXRzIGNvbnRhaW5lciBlbGVtZW50LiBUaGUgaW50ZXJuYWxcbiAgICAqIG1lc3NhZ2VzIHVzZSB0aGUgYG5nTWVzc2FnZWAgZGlyZWN0aXZlIGFuZCB3aWxsIGJlIGluc2VydGVkL3JlbW92ZWQgZnJvbSB0aGUgcGFnZSBkZXBlbmRpbmdcbiAgICAqIG9uIGlmIHRoZXkncmUgcHJlc2VudCB3aXRoaW4gdGhlIGtleS92YWx1ZSBvYmplY3QuIEJ5IGRlZmF1bHQsIG9ubHkgb25lIG1lc3NhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWRcbiAgICAqIGF0IGEgdGltZSBhbmQgdGhpcyBkZXBlbmRzIG9uIHRoZSBwcmlvcml0aXphdGlvbiBvZiB0aGUgbWVzc2FnZXMgd2l0aGluIHRoZSB0ZW1wbGF0ZS4gKFRoaXMgY2FuXG4gICAgKiBiZSBjaGFuZ2VkIGJ5IHVzaW5nIHRoZSBgbmctbWVzc2FnZXMtbXVsdGlwbGVgIG9yIGBtdWx0aXBsZWAgYXR0cmlidXRlIG9uIHRoZSBkaXJlY3RpdmUgY29udGFpbmVyLilcbiAgICAqXG4gICAgKiBBIHJlbW90ZSB0ZW1wbGF0ZSBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb21vdGUgbWVzc2FnZSByZXVzYWJpbGl0eSBhbmQgbWVzc2FnZXMgY2FuIGFsc28gYmVcbiAgICAqIG92ZXJyaWRkZW4uXG4gICAgKlxuICAgICoge0BsaW5rIG1vZHVsZTpuZ01lc3NhZ2VzIENsaWNrIGhlcmV9IHRvIGxlYXJuIG1vcmUgYWJvdXQgYG5nTWVzc2FnZXNgIGFuZCBgbmdNZXNzYWdlYC5cbiAgICAqXG4gICAgKiBAdXNhZ2VcbiAgICAqIGBgYGh0bWxcbiAgICAqIDwhLS0gdXNpbmcgYXR0cmlidXRlIGRpcmVjdGl2ZXMgLS0+XG4gICAgKiA8QU5ZIG5nLW1lc3NhZ2VzPVwiZXhwcmVzc2lvblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICogICA8QU5ZIG5nLW1lc3NhZ2U9XCJzdHJpbmdWYWx1ZVwiPi4uLjwvQU5ZPlxuICAgICogICA8QU5ZIG5nLW1lc3NhZ2U9XCJzdHJpbmdWYWx1ZTEsIHN0cmluZ1ZhbHVlMiwgLi4uXCI+Li4uPC9BTlk+XG4gICAgKiAgIDxBTlkgbmctbWVzc2FnZS1leHA9XCJleHByZXNzaW9uVmFsdWVcIj4uLi48L0FOWT5cbiAgICAqIDwvQU5ZPlxuICAgICpcbiAgICAqIDwhLS0gb3IgYnkgdXNpbmcgZWxlbWVudCBkaXJlY3RpdmVzIC0tPlxuICAgICogPG5nLW1lc3NhZ2VzIGZvcj1cImV4cHJlc3Npb25cIiByb2xlPVwiYWxlcnRcIj5cbiAgICAqICAgPG5nLW1lc3NhZ2Ugd2hlbj1cInN0cmluZ1ZhbHVlXCI+Li4uPC9uZy1tZXNzYWdlPlxuICAgICogICA8bmctbWVzc2FnZSB3aGVuPVwic3RyaW5nVmFsdWUxLCBzdHJpbmdWYWx1ZTIsIC4uLlwiPi4uLjwvbmctbWVzc2FnZT5cbiAgICAqICAgPG5nLW1lc3NhZ2Ugd2hlbi1leHA9XCJleHByZXNzaW9uVmFsdWVcIj4uLi48L25nLW1lc3NhZ2U+XG4gICAgKiA8L25nLW1lc3NhZ2VzPlxuICAgICogYGBgXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5nTWVzc2FnZXMgYW4gYW5ndWxhciBleHByZXNzaW9uIGV2YWx1YXRpbmcgdG8gYSBrZXkvdmFsdWUgb2JqZWN0XG4gICAgKiAgICAgICAgICAgICAgICAgKHRoaXMgaXMgdHlwaWNhbGx5IHRoZSAkZXJyb3Igb2JqZWN0IG9uIGFuIG5nTW9kZWwgaW5zdGFuY2UpLlxuICAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ01lc3NhZ2VzTXVsdGlwbGV8bXVsdGlwbGUgd2hlbiBzZXQsIGFsbCBtZXNzYWdlcyB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIHRydWVcbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogPGV4YW1wbGUgbmFtZT1cIm5nTWVzc2FnZXMtZGlyZWN0aXZlXCIgbW9kdWxlPVwibmdNZXNzYWdlc0V4YW1wbGVcIlxuICAgICogICAgICAgICAgZGVwcz1cImFuZ3VsYXItbWVzc2FnZXMuanNcIlxuICAgICogICAgICAgICAgYW5pbWF0aW9ucz1cInRydWVcIiBmaXhCYXNlPVwidHJ1ZVwiPlxuICAgICogICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICogICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICAqICAgICAgIDxsYWJlbD5cbiAgICAqICAgICAgICAgRW50ZXIgeW91ciBuYW1lOlxuICAgICogICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICogICAgICAgICAgICAgICAgbmFtZT1cIm15TmFtZVwiXG4gICAgKiAgICAgICAgICAgICAgICBuZy1tb2RlbD1cIm5hbWVcIlxuICAgICogICAgICAgICAgICAgICAgbmctbWlubGVuZ3RoPVwiNVwiXG4gICAgKiAgICAgICAgICAgICAgICBuZy1tYXhsZW5ndGg9XCIyMFwiXG4gICAgKiAgICAgICAgICAgICAgICByZXF1aXJlZCAvPlxuICAgICogICAgICAgPC9sYWJlbD5cbiAgICAqICAgICAgIDxwcmU+bXlGb3JtLm15TmFtZS4kZXJyb3IgPSB7eyBteUZvcm0ubXlOYW1lLiRlcnJvciB8IGpzb24gfX08L3ByZT5cbiAgICAqXG4gICAgKiAgICAgICA8ZGl2IG5nLW1lc3NhZ2VzPVwibXlGb3JtLm15TmFtZS4kZXJyb3JcIiBzdHlsZT1cImNvbG9yOm1hcm9vblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICogICAgICAgICA8ZGl2IG5nLW1lc3NhZ2U9XCJyZXF1aXJlZFwiPllvdSBkaWQgbm90IGVudGVyIGEgZmllbGQ8L2Rpdj5cbiAgICAqICAgICAgICAgPGRpdiBuZy1tZXNzYWdlPVwibWlubGVuZ3RoXCI+WW91ciBmaWVsZCBpcyB0b28gc2hvcnQ8L2Rpdj5cbiAgICAqICAgICAgICAgPGRpdiBuZy1tZXNzYWdlPVwibWF4bGVuZ3RoXCI+WW91ciBmaWVsZCBpcyB0b28gbG9uZzwvZGl2PlxuICAgICogICAgICAgPC9kaXY+XG4gICAgKiAgICAgPC9mb3JtPlxuICAgICogICA8L2ZpbGU+XG4gICAgKiAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAqICAgICBhbmd1bGFyLm1vZHVsZSgnbmdNZXNzYWdlc0V4YW1wbGUnLCBbJ25nTWVzc2FnZXMnXSk7XG4gICAgKiAgIDwvZmlsZT5cbiAgICAqIDwvZXhhbXBsZT5cbiAgICAqL1xuICAgLmRpcmVjdGl2ZSgnbmdNZXNzYWdlcycsIFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xuICAgICB2YXIgQUNUSVZFX0NMQVNTID0gJ25nLWFjdGl2ZSc7XG4gICAgIHZhciBJTkFDVElWRV9DTEFTUyA9ICduZy1pbmFjdGl2ZSc7XG5cbiAgICAgcmV0dXJuIHtcbiAgICAgICByZXF1aXJlOiAnbmdNZXNzYWdlcycsXG4gICAgICAgcmVzdHJpY3Q6ICdBRScsXG4gICAgICAgY29udHJvbGxlcjogWyckZWxlbWVudCcsICckc2NvcGUnLCAnJGF0dHJzJywgZnVuY3Rpb24oJGVsZW1lbnQsICRzY29wZSwgJGF0dHJzKSB7XG4gICAgICAgICB2YXIgY3RybCA9IHRoaXM7XG4gICAgICAgICB2YXIgbGF0ZXN0S2V5ID0gMDtcbiAgICAgICAgIHZhciBuZXh0QXR0YWNoSWQgPSAwO1xuXG4gICAgICAgICB0aGlzLmdldEF0dGFjaElkID0gZnVuY3Rpb24gZ2V0QXR0YWNoSWQoKSB7IHJldHVybiBuZXh0QXR0YWNoSWQrKzsgfTtcblxuICAgICAgICAgdmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcyA9IHt9O1xuICAgICAgICAgdmFyIHJlbmRlckxhdGVyLCBjYWNoZWRDb2xsZWN0aW9uO1xuXG4gICAgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24gfHwge307XG5cbiAgICAgICAgICAgcmVuZGVyTGF0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgY2FjaGVkQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgICAgICAgICAgLy8gdGhpcyBpcyB0cnVlIGlmIHRoZSBhdHRyaWJ1dGUgaXMgZW1wdHkgb3IgaWYgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBpcyB0cnV0aHlcbiAgICAgICAgICAgdmFyIG11bHRpcGxlID0gaXNBdHRyVHJ1dGh5KCRzY29wZSwgJGF0dHJzLm5nTWVzc2FnZXNNdWx0aXBsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyVHJ1dGh5KCRzY29wZSwgJGF0dHJzLm11bHRpcGxlKTtcblxuICAgICAgICAgICB2YXIgdW5tYXRjaGVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgdmFyIG1hdGNoZWRLZXlzID0ge307XG4gICAgICAgICAgIHZhciBtZXNzYWdlSXRlbSA9IGN0cmwuaGVhZDtcbiAgICAgICAgICAgdmFyIG1lc3NhZ2VGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICB2YXIgdG90YWxNZXNzYWdlcyA9IDA7XG5cbiAgICAgICAgICAgLy8gd2UgdXNlICE9IGluc3RlYWQgb2YgIT09IHRvIGFsbG93IGZvciBib3RoIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXNcbiAgICAgICAgICAgd2hpbGUgKG1lc3NhZ2VJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICB0b3RhbE1lc3NhZ2VzKys7XG4gICAgICAgICAgICAgdmFyIG1lc3NhZ2VDdHJsID0gbWVzc2FnZUl0ZW0ubWVzc2FnZTtcblxuICAgICAgICAgICAgIHZhciBtZXNzYWdlVXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgIGlmICghbWVzc2FnZUZvdW5kKSB7XG4gICAgICAgICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVXNlZCAmJiB0cnV0aHkodmFsdWUpICYmIG1lc3NhZ2VDdHJsLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCB0aGUgc2FtZSBlcnJvciBuYW1lIGZyb20gc2hvd2luZyB1cCB0d2ljZVxuICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkS2V5c1trZXldKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgbWF0Y2hlZEtleXNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICBtZXNzYWdlVXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgbWVzc2FnZUN0cmwuYXR0YWNoKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIGlmIChtZXNzYWdlVXNlZCkge1xuICAgICAgICAgICAgICAgLy8gdW5sZXNzIHdlIHdhbnQgdG8gZGlzcGxheSBtdWx0aXBsZSBtZXNzYWdlcyB0aGVuIHdlIHNob3VsZFxuICAgICAgICAgICAgICAgLy8gc2V0IGEgZmxhZyBoZXJlIHRvIGF2b2lkIGRpc3BsYXlpbmcgdGhlIG5leHQgbWVzc2FnZSBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgbWVzc2FnZUZvdW5kID0gIW11bHRpcGxlO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB1bm1hdGNoZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VDdHJsKTtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICBtZXNzYWdlSXRlbSA9IG1lc3NhZ2VJdGVtLm5leHQ7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBmb3JFYWNoKHVubWF0Y2hlZE1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlQ3RybCkge1xuICAgICAgICAgICAgIG1lc3NhZ2VDdHJsLmRldGFjaCgpO1xuICAgICAgICAgICB9KTtcblxuICAgICAgICAgICB1bm1hdGNoZWRNZXNzYWdlcy5sZW5ndGggIT09IHRvdGFsTWVzc2FnZXNcbiAgICAgICAgICAgICAgPyAkYW5pbWF0ZS5zZXRDbGFzcygkZWxlbWVudCwgQUNUSVZFX0NMQVNTLCBJTkFDVElWRV9DTEFTUylcbiAgICAgICAgICAgICAgOiAkYW5pbWF0ZS5zZXRDbGFzcygkZWxlbWVudCwgSU5BQ1RJVkVfQ0xBU1MsIEFDVElWRV9DTEFTUyk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICAkc2NvcGUuJHdhdGNoQ29sbGVjdGlvbigkYXR0cnMubmdNZXNzYWdlcyB8fCAkYXR0cnNbJ2ZvciddLCBjdHJsLnJlbmRlcik7XG5cbiAgICAgICAgIHRoaXMucmVSZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKCFyZW5kZXJMYXRlcikge1xuICAgICAgICAgICAgIHJlbmRlckxhdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAkc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIGlmIChyZW5kZXJMYXRlcikge1xuICAgICAgICAgICAgICAgICBjYWNoZWRDb2xsZWN0aW9uICYmIGN0cmwucmVuZGVyKGNhY2hlZENvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuXG4gICAgICAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24oY29tbWVudCwgbWVzc2FnZUN0cmwpIHtcbiAgICAgICAgICAgdmFyIG5leHRLZXkgPSBsYXRlc3RLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgbWVzc2FnZXNbbmV4dEtleV0gPSB7XG4gICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZUN0cmxcbiAgICAgICAgICAgfTtcbiAgICAgICAgICAgaW5zZXJ0TWVzc2FnZU5vZGUoJGVsZW1lbnRbMF0sIGNvbW1lbnQsIG5leHRLZXkpO1xuICAgICAgICAgICBjb21tZW50LiQkbmdNZXNzYWdlTm9kZSA9IG5leHRLZXk7XG4gICAgICAgICAgIGxhdGVzdEtleSsrO1xuXG4gICAgICAgICAgIGN0cmwucmVSZW5kZXIoKTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHRoaXMuZGVyZWdpc3RlciA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgdmFyIGtleSA9IGNvbW1lbnQuJCRuZ01lc3NhZ2VOb2RlO1xuICAgICAgICAgICBkZWxldGUgY29tbWVudC4kJG5nTWVzc2FnZU5vZGU7XG4gICAgICAgICAgIHJlbW92ZU1lc3NhZ2VOb2RlKCRlbGVtZW50WzBdLCBjb21tZW50LCBrZXkpO1xuICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNba2V5XTtcbiAgICAgICAgICAgY3RybC5yZVJlbmRlcigpO1xuICAgICAgICAgfTtcblxuICAgICAgICAgZnVuY3Rpb24gZmluZFByZXZpb3VzTWVzc2FnZShwYXJlbnQsIGNvbW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHByZXZOb2RlID0gY29tbWVudDtcbiAgICAgICAgICAgdmFyIHBhcmVudExvb2t1cCA9IFtdO1xuICAgICAgICAgICB3aGlsZSAocHJldk5vZGUgJiYgcHJldk5vZGUgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgIHZhciBwcmV2S2V5ID0gcHJldk5vZGUuJCRuZ01lc3NhZ2VOb2RlO1xuICAgICAgICAgICAgIGlmIChwcmV2S2V5ICYmIHByZXZLZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbcHJldktleV07XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLy8gZGl2ZSBkZWVwZXIgaW50byB0aGUgRE9NIGFuZCBleGFtaW5lIGl0cyBjaGlsZHJlbiBmb3IgYW55IG5nTWVzc2FnZVxuICAgICAgICAgICAgIC8vIGNvbW1lbnRzIHRoYXQgbWF5IGJlIGluIGFuIGVsZW1lbnQgdGhhdCBhcHBlYXJzIGRlZXBlciBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgIGlmIChwcmV2Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBwYXJlbnRMb29rdXAuaW5kZXhPZihwcmV2Tm9kZSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5wdXNoKHByZXZOb2RlKTtcbiAgICAgICAgICAgICAgIHByZXZOb2RlID0gcHJldk5vZGUuY2hpbGROb2Rlc1twcmV2Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBwcmV2Tm9kZSA9IHByZXZOb2RlLnByZXZpb3VzU2libGluZyB8fCBwcmV2Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBmdW5jdGlvbiBpbnNlcnRNZXNzYWdlTm9kZShwYXJlbnQsIGNvbW1lbnQsIGtleSkge1xuICAgICAgICAgICB2YXIgbWVzc2FnZU5vZGUgPSBtZXNzYWdlc1trZXldO1xuICAgICAgICAgICBpZiAoIWN0cmwuaGVhZCkge1xuICAgICAgICAgICAgIGN0cmwuaGVhZCA9IG1lc3NhZ2VOb2RlO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZpbmRQcmV2aW91c01lc3NhZ2UocGFyZW50LCBjb21tZW50KTtcbiAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgIG1lc3NhZ2VOb2RlLm5leHQgPSBtYXRjaC5uZXh0O1xuICAgICAgICAgICAgICAgbWF0Y2gubmV4dCA9IG1lc3NhZ2VOb2RlO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBtZXNzYWdlTm9kZS5uZXh0ID0gY3RybC5oZWFkO1xuICAgICAgICAgICAgICAgY3RybC5oZWFkID0gbWVzc2FnZU5vZGU7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VOb2RlKHBhcmVudCwgY29tbWVudCwga2V5KSB7XG4gICAgICAgICAgIHZhciBtZXNzYWdlTm9kZSA9IG1lc3NhZ2VzW2tleV07XG5cbiAgICAgICAgICAgdmFyIG1hdGNoID0gZmluZFByZXZpb3VzTWVzc2FnZShwYXJlbnQsIGNvbW1lbnQpO1xuICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICBtYXRjaC5uZXh0ID0gbWVzc2FnZU5vZGUubmV4dDtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBjdHJsLmhlYWQgPSBtZXNzYWdlTm9kZS5uZXh0O1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfV1cbiAgICAgfTtcblxuICAgICBmdW5jdGlvbiBpc0F0dHJUcnV0aHkoc2NvcGUsIGF0dHIpIHtcbiAgICAgIHJldHVybiAoaXNTdHJpbmcoYXR0cikgJiYgYXR0ci5sZW5ndGggPT09IDApIHx8IC8vZW1wdHkgYXR0cmlidXRlXG4gICAgICAgICAgICAgdHJ1dGh5KHNjb3BlLiRldmFsKGF0dHIpKTtcbiAgICAgfVxuXG4gICAgIGZ1bmN0aW9uIHRydXRoeSh2YWwpIHtcbiAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbC5sZW5ndGggOiAhIXZhbDtcbiAgICAgfVxuICAgfV0pXG5cbiAgIC8qKlxuICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICogQG5hbWUgbmdNZXNzYWdlc0luY2x1ZGVcbiAgICAqIEByZXN0cmljdCBBRVxuICAgICogQHNjb3BlXG4gICAgKlxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiBgbmdNZXNzYWdlc0luY2x1ZGVgIGlzIGEgZGlyZWN0aXZlIHdpdGggdGhlIHB1cnBvc2UgdG8gaW1wb3J0IGV4aXN0aW5nIG5nTWVzc2FnZSB0ZW1wbGF0ZVxuICAgICogY29kZSBmcm9tIGEgcmVtb3RlIHRlbXBsYXRlIGFuZCBwbGFjZSB0aGUgZG93bmxvYWRlZCB0ZW1wbGF0ZSBjb2RlIGludG8gdGhlIGV4YWN0IHNwb3RcbiAgICAqIHRoYXQgdGhlIG5nTWVzc2FnZXNJbmNsdWRlIGRpcmVjdGl2ZSBpcyBwbGFjZWQgd2l0aGluIHRoZSBuZ01lc3NhZ2VzIGNvbnRhaW5lci4gVGhpcyBhbGxvd3NcbiAgICAqIGZvciBhIHNlcmllcyBvZiBwcmUtZGVmaW5lZCBtZXNzYWdlcyB0byBiZSByZXVzZWQgYW5kIGFsc28gYWxsb3dzIGZvciB0aGUgZGV2ZWxvcGVyIHRvXG4gICAgKiBkZXRlcm1pbmUgd2hhdCBtZXNzYWdlcyBhcmUgb3ZlcnJpZGRlbiBkdWUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgbmdNZXNzYWdlc0luY2x1ZGUgZGlyZWN0aXZlLlxuICAgICpcbiAgICAqIEB1c2FnZVxuICAgICogYGBgaHRtbFxuICAgICogPCEtLSB1c2luZyBhdHRyaWJ1dGUgZGlyZWN0aXZlcyAtLT5cbiAgICAqIDxBTlkgbmctbWVzc2FnZXM9XCJleHByZXNzaW9uXCIgcm9sZT1cImFsZXJ0XCI+XG4gICAgKiAgIDxBTlkgbmctbWVzc2FnZXMtaW5jbHVkZT1cInJlbW90ZVRwbFN0cmluZ1wiPi4uLjwvQU5ZPlxuICAgICogPC9BTlk+XG4gICAgKlxuICAgICogPCEtLSBvciBieSB1c2luZyBlbGVtZW50IGRpcmVjdGl2ZXMgLS0+XG4gICAgKiA8bmctbWVzc2FnZXMgZm9yPVwiZXhwcmVzc2lvblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICogICA8bmctbWVzc2FnZXMtaW5jbHVkZSBzcmM9XCJleHByZXNzaW9uVmFsdWUxXCI+Li4uPC9uZy1tZXNzYWdlcy1pbmNsdWRlPlxuICAgICogPC9uZy1tZXNzYWdlcz5cbiAgICAqIGBgYFxuICAgICpcbiAgICAqIHtAbGluayBtb2R1bGU6bmdNZXNzYWdlcyBDbGljayBoZXJlfSB0byBsZWFybiBtb3JlIGFib3V0IGBuZ01lc3NhZ2VzYCBhbmQgYG5nTWVzc2FnZWAuXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5nTWVzc2FnZXNJbmNsdWRlfHNyYyBhIHN0cmluZyB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSByZW1vdGUgdGVtcGxhdGUuXG4gICAgKi9cbiAgIC5kaXJlY3RpdmUoJ25nTWVzc2FnZXNJbmNsdWRlJyxcbiAgICAgWyckdGVtcGxhdGVSZXF1ZXN0JywgJyRkb2N1bWVudCcsICckY29tcGlsZScsIGZ1bmN0aW9uKCR0ZW1wbGF0ZVJlcXVlc3QsICRkb2N1bWVudCwgJGNvbXBpbGUpIHtcblxuICAgICByZXR1cm4ge1xuICAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgIHJlcXVpcmU6ICdeXm5nTWVzc2FnZXMnLCAvLyB3ZSBvbmx5IHJlcXVpcmUgdGhpcyBmb3IgdmFsaWRhdGlvbiBzYWtlXG4gICAgICAgbGluazogZnVuY3Rpb24oJHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgdmFyIHNyYyA9IGF0dHJzLm5nTWVzc2FnZXNJbmNsdWRlIHx8IGF0dHJzLnNyYztcbiAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3Qoc3JjKS50aGVuKGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgJGNvbXBpbGUoaHRtbCkoJHNjb3BlLCBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICAgICAgIGVsZW1lbnQuYWZ0ZXIoY29udGVudHMpO1xuXG4gICAgICAgICAgICAgLy8gdGhlIGFuY2hvciBpcyBwbGFjZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgIHZhciBhbmNob3IgPSBqcUxpdGUoJGRvY3VtZW50WzBdLmNyZWF0ZUNvbW1lbnQoJyBuZ01lc3NhZ2VzSW5jbHVkZTogJyArIHNyYyArICcgJykpO1xuICAgICAgICAgICAgIGVsZW1lbnQuYWZ0ZXIoYW5jaG9yKTtcblxuICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gcG9sbHV0ZSB0aGUgRE9NIGFueW1vcmUgYnkga2VlcGluZyBhbiBlbXB0eSBkaXJlY3RpdmUgZWxlbWVudFxuICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9O1xuICAgfV0pXG5cbiAgIC8qKlxuICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICogQG5hbWUgbmdNZXNzYWdlXG4gICAgKiBAcmVzdHJpY3QgQUVcbiAgICAqIEBzY29wZVxuICAgICpcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogYG5nTWVzc2FnZWAgaXMgYSBkaXJlY3RpdmUgd2l0aCB0aGUgcHVycG9zZSB0byBzaG93IGFuZCBoaWRlIGEgcGFydGljdWxhciBtZXNzYWdlLlxuICAgICogRm9yIGBuZ01lc3NhZ2VgIHRvIG9wZXJhdGUsIGEgcGFyZW50IGBuZ01lc3NhZ2VzYCBkaXJlY3RpdmUgb24gYSBwYXJlbnQgRE9NIGVsZW1lbnRcbiAgICAqIG11c3QgYmUgc2l0dWF0ZWQgc2luY2UgaXQgZGV0ZXJtaW5lcyB3aGljaCBtZXNzYWdlcyBhcmUgdmlzaWJsZSBiYXNlZCBvbiB0aGUgc3RhdGVcbiAgICAqIG9mIHRoZSBwcm92aWRlZCBrZXkvdmFsdWUgbWFwIHRoYXQgYG5nTWVzc2FnZXNgIGxpc3RlbnMgb24uXG4gICAgKlxuICAgICogTW9yZSBpbmZvcm1hdGlvbiBhYm91dCB1c2luZyBgbmdNZXNzYWdlYCBjYW4gYmUgZm91bmQgaW4gdGhlXG4gICAgKiB7QGxpbmsgbW9kdWxlOm5nTWVzc2FnZXMgYG5nTWVzc2FnZXNgIG1vZHVsZSBkb2N1bWVudGF0aW9ufS5cbiAgICAqXG4gICAgKiBAdXNhZ2VcbiAgICAqIGBgYGh0bWxcbiAgICAqIDwhLS0gdXNpbmcgYXR0cmlidXRlIGRpcmVjdGl2ZXMgLS0+XG4gICAgKiA8QU5ZIG5nLW1lc3NhZ2VzPVwiZXhwcmVzc2lvblwiIHJvbGU9XCJhbGVydFwiPlxuICAgICogICA8QU5ZIG5nLW1lc3NhZ2U9XCJzdHJpbmdWYWx1ZVwiPi4uLjwvQU5ZPlxuICAgICogICA8QU5ZIG5nLW1lc3NhZ2U9XCJzdHJpbmdWYWx1ZTEsIHN0cmluZ1ZhbHVlMiwgLi4uXCI+Li4uPC9BTlk+XG4gICAgKiA8L0FOWT5cbiAgICAqXG4gICAgKiA8IS0tIG9yIGJ5IHVzaW5nIGVsZW1lbnQgZGlyZWN0aXZlcyAtLT5cbiAgICAqIDxuZy1tZXNzYWdlcyBmb3I9XCJleHByZXNzaW9uXCIgcm9sZT1cImFsZXJ0XCI+XG4gICAgKiAgIDxuZy1tZXNzYWdlIHdoZW49XCJzdHJpbmdWYWx1ZVwiPi4uLjwvbmctbWVzc2FnZT5cbiAgICAqICAgPG5nLW1lc3NhZ2Ugd2hlbj1cInN0cmluZ1ZhbHVlMSwgc3RyaW5nVmFsdWUyLCAuLi5cIj4uLi48L25nLW1lc3NhZ2U+XG4gICAgKiA8L25nLW1lc3NhZ2VzPlxuICAgICogYGBgXG4gICAgKlxuICAgICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ01lc3NhZ2V8d2hlbiBhIHN0cmluZyB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBtZXNzYWdlIGtleS5cbiAgICAqL1xuICAuZGlyZWN0aXZlKCduZ01lc3NhZ2UnLCBuZ01lc3NhZ2VEaXJlY3RpdmVGYWN0b3J5KCdBRScpKVxuXG5cbiAgIC8qKlxuICAgICogQG5nZG9jIGRpcmVjdGl2ZVxuICAgICogQG5hbWUgbmdNZXNzYWdlRXhwXG4gICAgKiBAcmVzdHJpY3QgQUVcbiAgICAqIEBzY29wZVxuICAgICpcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogYG5nTWVzc2FnZUV4cGAgaXMgYSBkaXJlY3RpdmUgd2l0aCB0aGUgcHVycG9zZSB0byBzaG93IGFuZCBoaWRlIGEgcGFydGljdWxhciBtZXNzYWdlLlxuICAgICogRm9yIGBuZ01lc3NhZ2VFeHBgIHRvIG9wZXJhdGUsIGEgcGFyZW50IGBuZ01lc3NhZ2VzYCBkaXJlY3RpdmUgb24gYSBwYXJlbnQgRE9NIGVsZW1lbnRcbiAgICAqIG11c3QgYmUgc2l0dWF0ZWQgc2luY2UgaXQgZGV0ZXJtaW5lcyB3aGljaCBtZXNzYWdlcyBhcmUgdmlzaWJsZSBiYXNlZCBvbiB0aGUgc3RhdGVcbiAgICAqIG9mIHRoZSBwcm92aWRlZCBrZXkvdmFsdWUgbWFwIHRoYXQgYG5nTWVzc2FnZXNgIGxpc3RlbnMgb24uXG4gICAgKlxuICAgICogQHVzYWdlXG4gICAgKiBgYGBodG1sXG4gICAgKiA8IS0tIHVzaW5nIGF0dHJpYnV0ZSBkaXJlY3RpdmVzIC0tPlxuICAgICogPEFOWSBuZy1tZXNzYWdlcz1cImV4cHJlc3Npb25cIj5cbiAgICAqICAgPEFOWSBuZy1tZXNzYWdlLWV4cD1cImV4cHJlc3Npb25WYWx1ZVwiPi4uLjwvQU5ZPlxuICAgICogPC9BTlk+XG4gICAgKlxuICAgICogPCEtLSBvciBieSB1c2luZyBlbGVtZW50IGRpcmVjdGl2ZXMgLS0+XG4gICAgKiA8bmctbWVzc2FnZXMgZm9yPVwiZXhwcmVzc2lvblwiPlxuICAgICogICA8bmctbWVzc2FnZSB3aGVuLWV4cD1cImV4cHJlc3Npb25WYWx1ZVwiPi4uLjwvbmctbWVzc2FnZT5cbiAgICAqIDwvbmctbWVzc2FnZXM+XG4gICAgKiBgYGBcbiAgICAqXG4gICAgKiB7QGxpbmsgbW9kdWxlOm5nTWVzc2FnZXMgQ2xpY2sgaGVyZX0gdG8gbGVhcm4gbW9yZSBhYm91dCBgbmdNZXNzYWdlc2AgYW5kIGBuZ01lc3NhZ2VgLlxuICAgICpcbiAgICAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNZXNzYWdlRXhwfHdoZW5FeHAgYW4gZXhwcmVzc2lvbiB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBtZXNzYWdlIGtleS5cbiAgICAqL1xuICAuZGlyZWN0aXZlKCduZ01lc3NhZ2VFeHAnLCBuZ01lc3NhZ2VEaXJlY3RpdmVGYWN0b3J5KCdBJykpO1xuXG5mdW5jdGlvbiBuZ01lc3NhZ2VEaXJlY3RpdmVGYWN0b3J5KHJlc3RyaWN0KSB7XG4gIHJldHVybiBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBRScsXG4gICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICAgIHJlcXVpcmU6ICdeXm5nTWVzc2FnZXMnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01lc3NhZ2VzQ3RybCwgJHRyYW5zY2x1ZGUpIHtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlID0gZWxlbWVudFswXTtcblxuICAgICAgICB2YXIgcmVjb3JkcztcbiAgICAgICAgdmFyIHN0YXRpY0V4cCA9IGF0dHJzLm5nTWVzc2FnZSB8fCBhdHRycy53aGVuO1xuICAgICAgICB2YXIgZHluYW1pY0V4cCA9IGF0dHJzLm5nTWVzc2FnZUV4cCB8fCBhdHRycy53aGVuRXhwO1xuICAgICAgICB2YXIgYXNzaWduUmVjb3JkcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgcmVjb3JkcyA9IGl0ZW1zXG4gICAgICAgICAgICAgID8gKGlzQXJyYXkoaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgID8gaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgOiBpdGVtcy5zcGxpdCgvW1xccyxdKy8pKVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgbmdNZXNzYWdlc0N0cmwucmVSZW5kZXIoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZHluYW1pY0V4cCkge1xuICAgICAgICAgIGFzc2lnblJlY29yZHMoc2NvcGUuJGV2YWwoZHluYW1pY0V4cCkpO1xuICAgICAgICAgIHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oZHluYW1pY0V4cCwgYXNzaWduUmVjb3Jkcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduUmVjb3JkcyhzdGF0aWNFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50LCBtZXNzYWdlQ3RybDtcbiAgICAgICAgbmdNZXNzYWdlc0N0cmwucmVnaXN0ZXIoY29tbWVudE5vZGUsIG1lc3NhZ2VDdHJsID0ge1xuICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhyZWNvcmRzLCBuYW1lKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICR0cmFuc2NsdWRlKHNjb3BlLCBmdW5jdGlvbihlbG0pIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihlbG0sIG51bGwsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gZWxtO1xuXG4gICAgICAgICAgICAgICAgLy8gRWFjaCB0aW1lIHdlIGF0dGFjaCB0aGlzIG5vZGUgdG8gYSBtZXNzYWdlIHdlIGdldCBhIG5ldyBpZCB0aGF0IHdlIGNhbiBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgYXJlIGRlc3Ryb3lpbmcgdGhlIG5vZGUgbGF0ZXIuXG4gICAgICAgICAgICAgICAgdmFyICQkYXR0YWNoSWQgPSBjdXJyZW50RWxlbWVudC4kJGF0dGFjaElkID0gbmdNZXNzYWdlc0N0cmwuZ2V0QXR0YWNoSWQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudCBpcyBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAvLyBieSBhbnkgb3RoZXIgc3RydWN0dXJhbCBkaXJlY3RpdmUgdGhlbiBpdCdzIHRpbWVcbiAgICAgICAgICAgICAgICAvLyB0byBkZXJlZ2lzdGVyIHRoZSBtZXNzYWdlIGZyb20gdGhlIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudC4kJGF0dGFjaElkID09PSAkJGF0dGFjaElkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5nTWVzc2FnZXNDdHJsLmRlcmVnaXN0ZXIoY29tbWVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQ3RybC5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBlbG0gPSBjdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV07XG5cbiAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwga2V5KSB7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBpc0FycmF5KGNvbGxlY3Rpb24pXG4gICAgICAgICAgPyBjb2xsZWN0aW9uLmluZGV4T2Yoa2V5KSA+PSAwXG4gICAgICAgICAgOiBjb2xsZWN0aW9uLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgfVxuICB9XG59XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCJyZXF1aXJlKCcuL2FuZ3VsYXItbWVzc2FnZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gJ25nTWVzc2FnZXMnO1xuIl19
